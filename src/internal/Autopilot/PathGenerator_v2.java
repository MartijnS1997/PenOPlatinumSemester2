package internal.Autopilot;

import AutopilotInterfaces.AutopilotInputs_v2;
import TestbedAutopilotInterface.Overseer.MapAirport;
import internal.Helper.SquareMatrix;
import internal.Helper.Vector;
import internal.Physics.PhysXEngine;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import static java.lang.Math.*;
import static java.lang.Math.cos;
import static java.lang.Math.sin;

/**
 * Created by Martijn on 25/04/2018.
 * created for testing purposes
 */
public class PathGenerator_v2{

	/**
	 * Constructor for a path generator to generate the turns
	 * @param currentInputs the current inputs of the drone
	 * @param destinationAirport the destination airport, this is the airport where to deliver the current package
	 * @param cruisingAltitude  the cruising altitude of the drone
	 * @param descendThreshold the threshold wherefore the descend phase is triggered, if this happens the offset for the landing needs to be adjusted
	 * @param standardDescendAltitude the standard descend altitude, this altitude is the altitude for which the drone starts to land
	 *                                if the descend threshold is breached
	 */
	public PathGenerator_v2(AutopilotInputs_v2 currentInputs, MapAirport destinationAirport, float cruisingAltitude, float descendThreshold, float standardDescendAltitude){
		Vector dronePosGround = Controller.extractGroundPosition(currentInputs);
		Vector droneOrientation = Controller.extractOrientation(currentInputs);
		//calculate the trajectory
		float landingAltitude = cruisingAltitude < descendThreshold? cruisingAltitude : standardDescendAltitude;
		generateTrajectory(dronePosGround, droneOrientation, destinationAirport,landingAltitude);
	}

	/**
	 * Getter for the next turn in the turn list, this is the next turn the drone should take to get to the target
	 * airport
	 * @return the next turn to make, if all the turns that were generated by the generator are made, returns a null
	 */
	public AutopilotTurn getNextTurn(){
		// get all the turns that are still to be delivered to the navigator
		List<AutopilotTurn> turns = this.getTurnList();
		int nbOfTurnsAvailable = turns.size();

		//if there are non left we shall return null
		if(nbOfTurnsAvailable == 0){
			return null;
		}

		//get the first element and remove it
		AutopilotTurn nextTurn =  turns.remove(0);

		return nextTurn;
	}

	/**
	 * Getter for the number of remaining turns, these are the turns that are generated for the navigator but
	 * were not yet requested by it
	 * @return the number of remaining turns to supply to the navigator
	 */
	public int getNbOfRemainingTurns(){
		List<AutopilotTurn> turns = this.getTurnList();
		return turns.size();
	}


	/**
	 * Generates the trajectory to be made by the drone to do the delivery
	 * @param dronePosGround the position of the drone in ground coordinates
	 * @param droneOrientation the orientation of the drone
	 * @param destinationAirport the destination airport
	 * @param landingAltitude the altitude at which the drone starts landing (needed to calculate the offset for the landing itself)
	 */
	private void generateTrajectory(Vector dronePosGround, Vector droneOrientation, MapAirport destinationAirport, float landingAltitude){
		//grab the parameters needed
		Vector airportLocation = destinationAirport.getLocation();
		//generate the center of the first turn
		TurnSpec firstTurn = this.getFirstTurnSpec(dronePosGround, droneOrientation, airportLocation);
		TurnSpec secondTurn = this.getSecondTurnSpec(dronePosGround, destinationAirport, landingAltitude);

		distanceCheck(firstTurn, secondTurn);

		//calculate the two tangents of the first turn (the base turn in tangent terminology)
		Tangent parallelTangent = calcParallelTangent(firstTurn, secondTurn);
		Tangent diagonalTangent = calcDiagonalTangent(firstTurn, secondTurn);

		//now get the tangent needed for the second turn
		Tangent pathToNextTurn = secondTurnTangentSelection(secondTurn, parallelTangent, diagonalTangent);

		//set the entry points of both turns relative to the center of the turn
		Vector entryFirstTurn = dronePosGround.vectorDifference(firstTurn.getTurnCenter());
		Vector entrySecondTurn = pathToNextTurn.getEndPoint().vectorDifference(secondTurn.getTurnCenter());
		firstTurn.setEntryPoint(entryFirstTurn);
		secondTurn.setEntryPoint(entrySecondTurn);

		//also set the exit point for both turns relative to the turn center for the first turn
		Vector exitFirstTurn = pathToNextTurn.getStartPoint();
		firstTurn.setExitPoint(exitFirstTurn);

		firstTurn.setTurnAngle();
		secondTurn.setTurnAngle();

		//save the generated turns in the list containing all the turns
		List<AutopilotTurn> turns = this.getTurnList();
		turns.add(firstTurn);
		turns.add(secondTurn);

		//save the flight path for future reference
		this.setFlightPath(new FlightPath(firstTurn, secondTurn));
	}

	/**
	 * Checks if the two generated turns may overlap (if the two circles defining the turns overlap)
	 * and prints error message to the user if so
	 * @param turn1 the first turn
	 * @param turn2 the second turn
	 */
	private void distanceCheck(TurnSpec turn1, TurnSpec turn2){
		Vector center1 = turn1.getTurnCenter();
		Vector center2 = turn2.getTurnCenter();
		float radius = this.getTurnRadius();
		if(center1.distanceBetween(center2) < 4*radius){
			System.out.println("Warning, the generated turns will overlap, may cause unpredictable behavior");
		}
	}

	/**
	 * Selects the tangent needed to enter the second turn correctly, meaning in the right direction
	 * @param secondTurn the second turn
	 * @param parallelTangent the parallel tangent (see parallel tangent calculator for more info)
	 * @param diagonalTangent the diagonal tangent (see diagonal tangent calculator for more info)
	 * @return the tangent required to enter the second turn in the same direction as specified in the turnspec
	 */
	private Tangent secondTurnTangentSelection(TurnSpec secondTurn, Tangent parallelTangent, Tangent diagonalTangent){
		//get data from the second turn
		Vector turnCenter = secondTurn.getTurnCenter();
		float radius = secondTurn.getTurnRadius();
		float turnDirection = secondTurn.getDirection();

		//extract the end points and the tangent vectors
		Vector parallelEndPoint = parallelTangent.getEndPoint();
		Vector diagonalEndPoint = diagonalTangent.getEndPoint();

//		System.out.println();
//		System.out.println("Turn one center: " + diagonalTangent.getTurn().getTurnCenter());
//		System.out.println("diagonal tangent start: " + diagonalTangent.getStartPoint().vectorSum(diagonalTangent.getTurn().getTurnCenter()));
//		System.out.println("Turn two center: " + secondTurn.getTurnCenter());
//		System.out.println("diagonal tangent end: " + diagonalTangent.getEndPoint());

		Vector pTangentVector = parallelTangent.getTangentVector();
		Vector dTangentVector = diagonalTangent.getTangentVector();

		//get both vectors pointing from the center of the turn to the end point of the tangent
		Vector entryParallel = parallelEndPoint.vectorDifference(turnCenter);
		Vector entryDiagonal = diagonalEndPoint.vectorDifference(turnCenter);

		//print the difference from the radius
//		System.out.println("calcError parallel: " + (entryParallel.getSize() - radius));
//		System.out.println("calcError diagonal: " + (entryDiagonal.getSize() - radius));
//		System.out.println();

		//determine the correct tangent by the cross product of the entry and the tangent, if the sign matches with the sign of the y-component
		//of the cross product we're good (always test for both just in case, will raise error but prevents us from having headache over bug)
		float parallelSign = signum(entryParallel.crossProduct(pTangentVector).getyValue());
		float diagonalSign = signum(entryDiagonal.crossProduct(dTangentVector).getyValue());

		if(parallelSign == signum(turnDirection)){
			System.out.println("parallel chosen");
			return parallelTangent;
		}
		if(diagonalSign == signum(turnDirection)){
			System.out.println("diagonal chosen");
			return diagonalTangent;
		}

		throw new IllegalStateException("some error occurred during calculation");
	}


	/**
	 * Calculates the turn center of the first turn, this is the turn made at the drone position
	 * @param dronePosGround the position of the drone relative to the ground
	 * @param droneOrientation the orientation of the drone
	 * @param destinationAirportLocation the location of the destination airport, used to generate the turn center
	 * @return the turn center for the first turn in world axis system
	 */
	private TurnSpec getFirstTurnSpec(Vector dronePosGround, Vector droneOrientation, Vector destinationAirportLocation){
		//get the parameters needed
		Vector xHeadingAxis = new Vector(1,0,0); //x_vector in heading axis
		float turnRadius = this.getTurnRadius();

		//get the vector pointing from the drone center to the airport
		Vector diffVector = destinationAirportLocation.vectorDifference(dronePosGround);

		//transform the x-heading axis to the world
		Vector xWorld = PhysXEngine.headingOnWorld(xHeadingAxis, droneOrientation);

		//project the difference vector onto the xWorld
		Vector projDiff = diffVector.projectOn(xWorld);

		//the projected difference indicates if the turn is to the left or to the right of the drone's current orientation
		//and if rescaled gives the center of the turn relative to the drone position
		Vector relTurnCenter = projDiff.normalizeToLength(turnRadius);
		Vector turnCenter = relTurnCenter.vectorSum(dronePosGround);

		//the projection diff indicates the direction, take the scalar product of the x vector in the world
		//and the projection diff, if the sign is negative we'll need a counterclockwise turn, if positive we'll need a
		//clockwise turn, the direction needs to be positive for counterclockwise and negative for clockwise so negate
		float scalarProd = projDiff.scalarProduct(xWorld);
		float direction = -signum(scalarProd);

		return new TurnSpec(turnCenter, turnRadius, direction);
	}

	/**
	 * Getter for the location of the second turn center
	 * @param dronePosGround the position of the drone if only x and z coordinates are considered
	 * @param airport the airport we have to generate a path to
	 * @return the turn center of the second turn
	 * note: the exit point of the turn spec is also set in this method
	 */
	private TurnSpec getSecondTurnSpec(Vector dronePosGround, MapAirport airport, float cruisingAltitude){
		Vector airportHeading = airport.getHeadingVector();
		Vector airportLocation = airport.getLocation();
		float runwayLength = airport.getRunwayLength();
		float landingDistance = this.landingDistance(cruisingAltitude);
		float turnRadius = this.getTurnRadius();
		//first calculate the right turning axis system used to find the entry point for the drone at the airport
		//this is the vector that is to the right of the heading
		Vector rightOrthogonal = getRightOrthogonal(airportHeading);

		//get the difference vector between the airport and the drone
		Vector diffVector = dronePosGround.vectorDifference(airportLocation);

		//project the difference vector onto the right orthogonal and the heading to discover the turn center location
		//the turn center should be located in the same quadrant as the difference vector if viewed from the axis system
		//spanned by the heading vector and the right orthogonal
		Vector projOnRightOrth = diffVector.projectOn(rightOrthogonal);
		Vector projOnHeading = diffVector.projectOn(airportHeading);

		//resize for the correct location relative to the airport center
		Vector scaledRightOrth = projOnRightOrth.normalizeToLength(turnRadius);
		Vector scaledHeadingComp = projOnHeading.normalizeToLength(2*runwayLength + landingDistance);

		//the turn center relative to the airport center
		Vector turnCenterRel = scaledHeadingComp.vectorSum(scaledRightOrth);

		//sum it all up to get the center
		Vector turnCenter = turnCenterRel.vectorSum(airportLocation);

		//we'll also need the direction
		//determine via the scalar product with the heading vector of the airport and the pointer from
		// airport center to turn center & the scalar  product of the right orthogonal and the same pointer
		//if the product of both scalar products is positive a counter clockwise rotation is needed
		//conversely a negative product needs a clockwise entry
		Vector airportToTurn = turnCenter.vectorDifference(airportLocation);
		float orthogonalScalar = airportToTurn.scalarProduct(rightOrthogonal);
		float headingScalar = airportToTurn.scalarProduct(airportHeading);
		float direction = signum(orthogonalScalar*headingScalar);

		Vector exitPointAbs = scaledHeadingComp.vectorSum(airportLocation);
		Vector exitPointRel = exitPointAbs.vectorDifference(turnCenter);
		//generate the new turn spec
		TurnSpec secondTurn =  new TurnSpec(turnCenter, turnRadius, direction);
		secondTurn.setExitPoint(exitPointRel);

		return secondTurn;
	}

	/**
	 * Calculates the landing distance needed for landing the drone for the given altitude
	 * (for now a lineair approx is used)
	 * @param landingAltitude the altitude from which the drone starts descending
	 * @return the landing distance needed to get the drone on the landing strip
	 */
	private float landingDistance(float landingAltitude){
		float c1 = 9.2f;
		return c1*landingAltitude;
	}

	/**
	 * Calculates the parallel tangent for the given base turn, the parallel tangent points from the base turn
	 * to the target turn in the same direction as the rotation of the turn, the tangent is determined by the
	 * difference vector between the two centers of the turns
	 * @param baseTurn the base turn, the turn must already have its direction and center initialized
	 * @param targetTurn  the target turn, the turn must already have it center initialized
	 * @return the tangent that points from the base turn to a point on the target turn, with the orientation
	 *         of the tangent parallel to the line that connects both centers
	 */
	private Tangent calcParallelTangent(TurnSpec baseTurn, TurnSpec targetTurn){
		float direction = baseTurn.getDirection();
		float radius = baseTurn.getTurnRadius();
		//get the connection vector of the two turns, we point from the base center to the target
		Vector baseCenter = baseTurn.getTurnCenter();
		Vector targetCenter = targetTurn.getTurnCenter();
		Vector connectionVector = targetCenter.vectorDifference(baseCenter);

		//now we need to calculate the start point of the parallel tangent in the base turn
		//we do this by taking the right orthogonal of the connection vector and scaling it to the
		//radius of the turn
		Vector rightOrthConnection = getRightOrthogonal(connectionVector);
		//if the turn direction is positive (meaning counter clock wise rotation) the right orthogonal
		//scaled to the turn radius is the vector pointing from the center of the turn to the start point of the turn
		//if the turn direction is negative (meaning the counter clockwise rotation) the start point is the left
		//orthogonal, meaning we must scale the right orthogonal to the turn radius and multiply with -1
		Vector scaledRightOrth = rightOrthConnection.normalizeToLength(radius);
		Vector startPoint = scaledRightOrth.scalarMult(signum(direction));

		//the tangent vector is nothing more than the connection vector, we can now calculate the tangent vector
		return new Tangent(baseTurn, startPoint, connectionVector);
	}

	/**
	 * Calculates the common tangent of the base turn and the target turn that crosses the connection line
	 * between these turns
	 * @param baseTurn the base turn, this is the turn to start from
	 * @param targetTurn the target turn, the tangent will point to a point on this turn and will be
	 *                   perpendicular to the radius vector of that point (the vector pointing from the center of the
	 *                   target turn to this point)
	 * @return the diagonal tangent with the properties described above
	 */
	private Tangent calcDiagonalTangent(TurnSpec baseTurn, TurnSpec targetTurn) {
		//get the centers, we'll need them to calculate the connection vector
		Vector baseCenter = baseTurn.getTurnCenter();
		Vector targetCenter = targetTurn.getTurnCenter();

		//calculate the connection vector, the vector pointing from the base center to the target center
		//we'll also need the center of the connection vector
		Vector connectionVector = targetCenter.vectorDifference(baseCenter);
		Vector connectionCenter = connectionVector.scalarMult(0.5f);

		//calculate the angles needed to find the start position of the turn
		//see drawing for more info --> ask Martijn
		float radius = baseTurn.getTurnRadius();
		float conCenterSize = connectionCenter.getSize(); // the size of the connection center
		float baseDir = baseTurn.getDirection();
		//the rotation angle needed to rotate along -connectionCenter, is negative for clockwise rotation
		//and positive for counter clockwise
		float rotationAngle = (float)(signum(baseDir) * abs(asin(radius/conCenterSize)));
		Vector negConCenter = connectionCenter.scalarMult(-1f);
		//calculate the vector pointing from the center of the connection to the exit of the turn
		Vector conCenterToExit = rotateVector(negConCenter, rotationAngle);
		//set the vector to scale
		float length = (float) sqrt(conCenterSize*conCenterSize - radius*radius);
		Vector scaledConCenterToExit = conCenterToExit.normalizeToLength(length);

		//get the relative position to the center of the first turn of the exit point
		Vector exitPoint = connectionCenter.vectorSum(scaledConCenterToExit);
		System.out.println("exit point: " + exitPoint);

		//now calculate the tangent, this is the connection center to exit vector times -2 (to turn it around and
		Vector tangent = scaledConCenterToExit.scalarMult(-2f);

		//the tangent starts at the exit point of the base turn and points from this exit point to the next entry point
		return new Tangent(baseTurn, exitPoint, tangent);
	}

	/**
	 * rotates the given turn vector along the given angle in the xz-plane
	 * if the angle is positive the turn vector is rotated anti-clockwise
	 * if the angle is negative the turn vector is rotated clockwise
	 * @param vector the vector to rotate for the given angle
	 * @param angle the angle to rotate the turn vector for (in radians)
	 * @return a vector that is rotated as described above
	 */
	public Vector rotateVector(Vector vector, float angle){
		//create a new square matrix
		float[] matrixArray = new float[]{(float) cos(angle), 0, (float) sin(angle),
				0,1,0,
				(float) -sin(angle), 0, (float) cos(angle)};
		SquareMatrix rotationMatrix = new SquareMatrix(matrixArray);
		//transform
		return rotationMatrix.matrixVectorProduct(vector);
	}

	/**
	 * Calculates the vector that is located to the right of the given vector and stands orthogonal to it
	 * (as viewed looking along the vector)
	 * @param vector a vector with only 2d coordinates specified in the xz-axis system (x, 0, z)
	 * @return a vector containing the right orthogonal to the supplied vector
	 */
	private static Vector getRightOrthogonal(Vector vector){
		return new Vector(-vector.getzValue(), 0, vector.getxValue());
	}

	/**
	 * Getter for the total number of turns generated by the path generator
	 * --> standard 2, but we make this function more generic, just in case we need more turns
	 * @return the number of turns generated by the path generator
	 */
	public int getTotalNbOfTurns(){
		List<AutopilotTurn> turns = this.getTurnList();
		return turns.size();
	}

	/**
	 * Getter for the turn list, this is the list containing all the turns to be made by the autopilot
	 * @return the list containing all the turns
	 */
	private List<AutopilotTurn> getTurnList() {
		return turnList;
	}


	/**
	 * Getter for the turning radius of the turns generated by the path generator
	 * --> for now all the radii are the same
	 * @return the turning radius in meters
	 */
	private float getTurnRadius() {
		return turnRadius;
	}

	/**
	 * Setter for the turning radius of the turns generated by the path generator
	 * @param turnRadius the turn radius in meters
	 */
	private void setTurnRadius(float turnRadius) {
		this.turnRadius = turnRadius;
	}

	/**
	 * Getter for the flight path generated by the generator
	 * this path is used by the autopilot to avoid collisions
	 * @return the flight path of the drone
	 */
	protected FlightPath getFlightPath() {
		return flightPath;
	}

	/**
	 * Setter for the flight path generated by the generator
	 * @param flightPath the flight path to be set
	 */
	private void setFlightPath(FlightPath flightPath) {
		this.flightPath = flightPath;
	}

	/**
	 * A list containing the turns to be made by the autopilot
	 */
	private List<AutopilotTurn> turnList = new LinkedList<>();

	/**
	 * The standard turn radius used by the path generator. This is the radius used
	 * for the turns generated
	 */
	private float turnRadius = 1000f;

	/**
	 * The total flight path generated by the path generator
	 * this variable is used by the controls to avoid collision
	 */
	private FlightPath flightPath;


	/**
	 * A class to save the specifications of a turn in construction progress (provided object to store intermediary results)
	 */
	private class TurnSpec implements AutopilotTurn{

		public TurnSpec(Vector turnCenter, float turnRadius, float direction) {
			this.turnCenter = turnCenter;
			this.turnRadius = turnRadius;
			this.direction = direction;
		}


		/**
		 * Sets the turn angle by calculating it based on the entry and exit points together with
		 * the direction of the turn, the angle is set negative if the turn is clockwise
		 * and positive is the turn is counterclockwise
		 */
		private void setTurnAngle(){
			//get the data of the turn
			//the direction
			float direction = this.getDirection();
			//get the relative exit and entry points
			Vector entry = this.getEntryPoint();
			Vector exit = this.getExitPoint();

			//then calc the angle between them (but first normalize
			entry = entry.normalizeVector();
			exit = exit.normalizeVector();

			float angle = abs(entry.getAngleBetween(exit));

			//then check if the angle is right for the direction  by taking the cross product between the entry and exit
			//point and keeping only the y-component, if it is negative the angle goes clockwise,
			// if positive the angle goes clockwise, if this does not
			//match the direction indicated by the turn (direction param) we must subtract the angle from 2PI
			float angleDir = entry.crossProduct(exit).getyValue();
			//compare the signa
			if(signum(angleDir) != signum(direction)){
				angle = (float) (2*PI - angle);
			}
			//if the angle is very close to 2PI, we should just fly straight instead of making a full 360
			if(floatEquals(abs(angle), (float) (2*PI))){
				angle = 0f;
			}
			//now set the sign of the angle right (pos for counter, neg for clock --> contained within direction)
			float turnAngle = angle*signum(direction);

			this.turnAngle = turnAngle;
		}

		private boolean floatEquals(float f1, float f2){
			return Math.abs(f1 - f2)/f1 < EPSILON;
		}

		//TODO document getters and setters

		/**
		 * Getter for the turn center of the current turn --> see interface for more info
		 * @return the turn center in world axis system in ground coordinates (x, 0, z)
		 */
		@Override
		public Vector getTurnCenter() {
			return turnCenter;
		}

		/**
		 * Setter for the turn center of the turn (see getter)
		 * @param turnCenter the turn center
		 */
		private void setTurnCenter(Vector turnCenter) {
			this.turnCenter = turnCenter;
		}

		/**
		 * Getter for the entry point of the turn in ground coordinates, relative to the center of the turn
		 * --> see interface documentation for more info
		 * @return the entry point of the turn in ground coordinates (x, 0, z)
		 */
		@Override
		public Vector getEntryPoint() {
			return entryPoint;
		}

		/**
		 * Setter for the entry point of the turn --> see getter for more info
		 * @param entryPoint the entry point of the turn in ground coordinates, relative to the center of the turn
		 */
		private void setEntryPoint(Vector entryPoint) {
			this.entryPoint = entryPoint;
		}

		/**
		 * Getter for the exit point of the turn
		 * --> see interface for more info
		 * @return the exit point in ground coordinates (x, 0, z) relative to the center of the turn
		 */
		@Override
		public Vector getExitPoint() {
			return exitPoint;
		}

		/**
		 * Setter for the exit point of the current turn
		 * @param exitPoint the exit point of the turn in ground coordinates (x, 0, z), relative to the center of the turn
		 */
		private void setExitPoint(Vector exitPoint) {
			this.exitPoint = exitPoint;
		}

		/**
		 * Getter for the turn radius, the radius of the turn
		 * every turn generated by the generator has the same radius for ease of calculation
		 * @return the radius of the turn in meters
		 */
		@Override
		public float getTurnRadius() {
			return turnRadius;
		}

		/**
		 * Setter for the turn radius, this is the desired radius of the turn
		 * @param turnRadius the radius of the turn in meters
		 */
		private void setTurnRadius(float turnRadius) {
			this.turnRadius = turnRadius;
		}

		/**
		 * Getter for the direction of the turn, is positive if the turn should be taken counter clockwise
		 * is negative if the turn should be taken clockwise
		 * @return a positive floating point number for a clockwise turn, and a negative one for a clockwise turn
		 */
		private float getDirection() {
			return direction;
		}

		/**
		 * Setter for the direction of the turn
		 * @param direction the direction of the turn (negative for clockwise, positive for counter clockwise)
		 */
		private void setDirection(float direction) {
			this.direction = direction;
		}

		/**
		 * Getter for the turn angle, this is the angle of the total turn to be made by the drone, the sign indicates
		 * the direction of the turn in the same manner as described in the getDirection() method
		 * @return the turn angle in radians, negative for a clockwise turn and positive for a counter clockwise turn
		 */
		public float getTurnAngle(){
			return turnAngle;
		}

		/**
		 * The center of the turn (x,0,z)
		 */
		private Vector turnCenter;

		/**
		 * The entry point of the turn relative to the center of the drone
		 */
		private Vector entryPoint;

		/**
		 * The exit point of the turn relative to the turn center
		 */
		private Vector exitPoint;

		/**
		 * The radius of the turn to make
		 */
		private float turnRadius;

		/**
		 * the direction of the turn values < 0 indicate clockwise rotation around the center
		 *                                  >= 0 indicates counter clockwise rotation around the center
		 */
		private float direction;

		/**
		 * The angle the drone has to turn around the center, a negative angle represents a clockwise turn
		 * and a positive angle represents a counter clockwise turn
		 */
		private float turnAngle;

		/**
		 * The maximum relative error when comparing two floats
		 */
		private final static float EPSILON = 10E-4f;
	}

	/**
	 * A class of tangent specifications, used to resolve the correct path for the generator
	 */
	private class Tangent{

		/**
		 * Constructor for a tangent, this is a vector that starts at the edge of the specified turn, is perpendicular
		 * to the radius and points to a point on the next turn and is also perpendicular to the next turn
		 * @param turn the turn of origin, this is the turn where the tangent starts
		 * @param startPoint the start point of the tangent (in ground coordinates (x, 0, z) ) relative to
		 *                   the center of the specified turn
		 * @param tangentVector the tangent vector, this is the vector that points from the start point to a point on the
		 *                      next turn, is also perpendicular to the second turn
		 */
		private Tangent(TurnSpec turn, Vector startPoint, Vector tangentVector){
			this.turn = turn;
			this.startPoint = startPoint;
			this.tangentVector = tangentVector;
		}


		/**
		 * Calculates the exit point of the tangent in the world axis system (x, 0, z)
		 * this is the point where the tangent also touches the other turn
		 * @return the end point of the tangent in ground coordinate world axis system
		 */
		private Vector getEndPoint(){
			//get the turn center, this is our base
			TurnSpec turn = this.getTurn();
			Vector turnCenter = turn.getTurnCenter();
			Vector startPoint = this.getStartPoint();
			Vector tangent = this.getTangentVector();

			//calculate the absolute position of the start point
			Vector absStart = turnCenter.vectorSum(startPoint);

			//add the tangent to get the end point of the tangent
			return absStart.vectorSum(tangent);
		}


		/**
		 * Getter for the turn that forms the base for the tangent (this is where the tangent vector originates from)
		 * @return a turn that forms the base for the tangent
		 */
		private TurnSpec getTurn() {
			return turn;
		}

		/**
		 * Getter for the start point, this is the point where the tangent starts and is specified relative to
		 * the center of the base turn (in ground coordinates)
		 * @return the start point, relative to the base turn
		 */
		private Vector getStartPoint() {
			return startPoint;
		}

		/**
		 * The tangent vector, this is the vector that points from the start point to the entry point of the drone
		 * for the next turn, the tangent is perpendicular to the radii of both turns
		 * @return the tangent vector in ground coordinates (x, 0, z)
		 */
		private Vector getTangentVector() {
			return tangentVector;
		}

		/**
		 * The turn the tangent is associated with
		 */
		private final TurnSpec turn;

		/**
		 * The start point of the tangent relative to the center of the turn associated with the tangent
		 */
		private final Vector startPoint;

		/**
		 * The vector pointing from the start point along the direction of the tangent
		 */
		private final Vector tangentVector;
	}
}

//package internal.Autopilot;
//
//import java.util.ArrayList;
//import java.util.List;
//
//import AutopilotInterfaces.AutopilotInputs_v2;
//import TestbedAutopilotInterface.Overseer.MapAirport;
//import internal.Helper.Vector;
//import internal.Physics.PhysXEngine;
//
///**
// * Class for generating (landing) paths
// * @author Anthony Rathe
// *
// */
//public class PathGenerator_v2 {
//
//	/**
//	 * Initialize a path generator without any variables. Variables should be provided with the 'updateVariables' method.
//	 */
//	public PathGenerator_v2() {
//
//	}
//
//	/**
//	 * Initialize a path generator and provide it with the required variables.
//	 * (see updateVariables for meaning of variables)
//	 */
//	public PathGenerator_v2(Vector position, Vector heading, Vector landingPosition, Vector landingOrientation) {
//		setPosition(position);
//		setOrientation(heading);
//		setLandingPosition(landingPosition);
//		setLandingOrientation(landingOrientation);
//		generatePath();
//	}
//
//	/**
//	 * Constructor for the path generator based on the current inputs of the drone and the
//	 * destination airport for the current package
//	 * also calls the generate path functionality on construction so the user is not concerned with the inner
//	 * workings of the path generator
//	 * @param currentInputs the inputs most recently received from the testbed
//	 * @param destinationAirport the airport that the generator has to generate a path to
//	 */
//	public PathGenerator_v2(AutopilotInputs_v2 currentInputs, MapAirport destinationAirport){
//		setDroneParameters(currentInputs);
//		setAirportParameters(destinationAirport, currentInputs);
//		System.out.println("Data fed to the generator, drone pos: " + getCurrentPosition() + ", drone heading: " + getOrientation()
//				+ ", airport entry point: " + getLandingPosition() + ", airport landing direction: " + getLandingOrientation());
//		generatePath();
//	}
//
//	/**
//	 * Setter for the parameters of the drone needed for the path generation calculations
//	 * @param currentInputs the inputs most recently received from the testbed
//	 */
//	private void setDroneParameters(AutopilotInputs_v2 currentInputs) {
//		//extract the variables needed to calculate the heading
//		Vector dronePosition = Controller.extractPosition(currentInputs);
//		Vector droneOrientation = Controller.extractOrientation(currentInputs);
//		Vector headingVector = getHeadingVector(droneOrientation);
//
//		setPosition(dronePosition);
//		setOrientation(headingVector);
//	}
//
//	/**
//	 * Calculates the heading of the drone in the world axis system from the orientation
//	 * the heading is expressed in x-z coordinates (x, 0, z)
//	 * @param droneOrientation the orientation of the drone (heading, pitch and roll)
//	 * @return the heading vector of the drone
//	 */
//	private static Vector getHeadingVector(Vector droneOrientation){
//		//grab the parameters needed
//		Vector headingDroneHa = new Vector(0,0,-1); //heading of the drone in heading axis
//		return PhysXEngine.headingOnWorld(headingDroneHa, droneOrientation);
//	}
//
//	private void setAirportParameters(MapAirport airport, AutopilotInputs_v2 currentInputs){
//		//get the position of the drone, we need this to determine the entry point
//		Vector dronePosGround = Controller.extractGroundPosition(currentInputs);
//		//get the runway ends for distance calculation, we need this to get the landing orientation
//		Vector runwayZeroEnd = airport.getRunwayZeroEnd();
//		Vector runwayOneEnd = airport.getRunwayOneEnd();
//		//get the touchdown position and the landing orientation
//		float distanceToRunwayZero = dronePosGround.distanceBetween(runwayZeroEnd);
//		float distanceToRunwayOne = dronePosGround.distanceBetween(runwayOneEnd);
//
//		Vector touchdownPos = distanceToRunwayZero <= distanceToRunwayOne ? runwayZeroEnd : runwayOneEnd;
//		Vector landingOrientation = distanceToRunwayZero <= distanceToRunwayOne ?
//				airport.getRunwayZeroLandingDirection() : airport.getRunwayOneLandingDirection();
//
//		//set the results
//		this.setLandingPosition(touchdownPos);
//		this.setLandingOrientation(landingOrientation);
//	}
//
//	private Vector position;
//	private Vector orientation;
//	private Vector landingPosition;
//	private Vector landingOrientation;
//
//	/**
//	 * Updates all variables required for generating a useable path.
//	 * @param position: current drone position
//	 * @param orientation: current drone orientation (only x- and z- components will be considered)
//	 * @param landingPosition: the desired touchdown position
//	 * @param landingOrientation: the orientation of the landing strip (pointing in the landing direction)(only x- and z- components will be considered)
//	 */
//	public void updateVariables(Vector position, Vector orientation, Vector landingPosition, Vector landingOrientation) {
//		setPosition(position);
//		setOrientation(orientation);
//		setLandingPosition(landingPosition);
//		setLandingOrientation(landingOrientation);
//	}
//
//	// Getters and setters
//
//	public Vector getCurrentPosition() {
//		return this.position;
//	}
//
//	public void setPosition(Vector position) {
//		this.position = position;
//	}
//
//	public Vector getLandingPosition() {
//		return this.landingPosition;
//	}
//
//	public void setLandingPosition(Vector landingPosition) {
//		this.landingPosition = landingPosition;
//	}
//
//	public Vector getOrientation() {
//		return this.orientation;
//	}
//
//	public void setOrientation(Vector orientation) {
//		this.orientation = orientation;
//	}
//
//	public Vector getLandingOrientation() {
//		return this.landingOrientation;
//	}
//
//	public void setLandingOrientation(Vector landingOrientation) {
//		this.landingOrientation = landingOrientation;
//	}
//
//	// Useful methods
//
//	/**
//	 * Generates the position starting from which the plane should start
//	 * descending in a straight line and under an angle of 10 degrees
//	 * in order to touch down on the required position.
//	 * @return
//	 */
//	private Vector getDescentStartPosition() {
//		Vector position = getCurrentPosition();
//		Vector landingPosition = getLandingPosition();
//		float heightDifference = position.getyValue()-landingPosition.getyValue();
//		float a = (float) (heightDifference/Math.sin(getLandingAngle()));
//
//		Vector landingVector = getLandingVector().normalizeToLength(a);
//		return landingPosition.vectorSum(landingVector);
//	}
//
//	/**
//	 * Generates the descent vector: a normalized vector
//	 * that has an angle with the horizon of 10 degrees and points upwards
//	 */
//	private Vector getLandingVector() {
//		Vector landingOrientation = getLandingOrientation().makeHorizontal().normalizeToLength(-1f);
//		float r = landingOrientation.getSize();
//		return new Vector(landingOrientation.getxValue(), (float)(r*Math.tan((float)getLandingAngle())), landingOrientation.getzValue()).normalizeVector();
//	}
//
//	/*
//	 * PURE CHaos
//	private Vector getPointOfIntersection() {
//		Vector position = getCurrentPosition().makeHorizontal();
//		Vector landingPosition = getLandingPosition().makeHorizontal();
//		Vector orientation = getOrientation().makeHorizontal();
//		Vector landingOrientation = getLandingOrientation().makeHorizontal();
//
//		float a_x = landingPosition.getxValue();
//		float a_y = landingPosition.getzValue();
//
//		float b_x = position.getxValue();
//		float b_y = position.getzValue();
//
//		float c_x = landingOrientation.getxValue();
//		float c_y = landingOrientation.getzValue();
//
//		float d_x = orientation.getxValue();
//		float d_y = orientation.getzValue();
//
//		float q_x;
//		float q_y;
//		if (c_x != 0) {
//			float r = (a_y + (b_x-a_x)*c_y/c_x - b_y)/(d_y - d_x*c_y/c_x);
//			q_x = r*d_x + b_x;
//			q_y = r*d_y + b_y;
//		}else {
//			q_x = a_x;
//			q_y = (a_x - b_y)*d_y/d_x + b_y;
//		}
//
//
//		return new Vector(q_x, 0f, q_y);
//
//	}
//
//	public void generatePath() {
//		Vector position = getCurrentPosition().makeHorizontal();
//		Vector orientation = getOrientation().makeHorizontal();
//		Vector descentStartPosition = getDescentStartPosition().makeHorizontal();
//		Vector descentStartOrientation = getLandingOrientation().makeHorizontal();
//
//		// First we check if we can generate a path with only a single turn
//		Vector intersection = getPointOfIntersection();
//		float alfa = orientation.getAngleBetween(descentStartOrientation);
//		float R = getStandardRadius();
//		float L = R/(float)(Math.cos(alfa/2));
//		float l = L*(float)(Math.sin(alfa/2));
//
//		Vector L_vector;
//		Vector l_in_vector = orientation.normalizeToLength(-l);
//		Vector l_out_vector;
//		if (descentStartPosition.toTheRightOf(position, orientation)) {
//			L_vector = orientation.normalizeToLength(-L).rotateAroundYAxis(((float)Math.PI-alfa)/2f);
//			l_out_vector = l_in_vector.rotateAroundYAxis(((float)Math.PI-alfa)/2f);
//		}else {
//			L_vector = orientation.normalizeToLength(-L).rotateAroundYAxis(-((float)Math.PI-alfa)/2f);
//			l_out_vector = l_in_vector.rotateAroundYAxis(-((float)Math.PI-alfa)/2f);
//		}
//
//		Vector center = intersection.vectorSum(L_vector);
//		Vector in = intersection.vectorSum(l_in_vector);
//		Vector out = intersection.vectorSum(l_out_vector);
//
//		float turnAngle = out.vectorDifference(center).getAngleBetween(in.vectorDifference(center));
//		if (descentStartPosition.toTheRightOf(position, orientation)) {
//			// Turn to the right, so angle turnAngle should be negative
//			turnAngle = -turnAngle;
//		}
//
//
//		// Alfa is the angle of the subsection of circle that is traversed
//		// R is the radius of that circle
//		// in is the entry point of the circle
//		// out is the exit point of the circle
//
//		float a = out.distanceBetween(descentStartPosition, descentStartOrientation);
//		float b = position.distanceBetween(in, orientation);
//
//		if (a >= 0 && b >= 0 && alfa != (float)Math.PI && alfa != 0f) {
//			// It is possible to generate a path with only one turn
//			AutopilotTurn firstTurn = new Turn(in, center, out, turnAngle, R);
//			addTurn(firstTurn);
//			System.out.println(in);
//			System.out.println(center);
//			System.out.println(out);
//		}else {
//			// Generate an S-path with two turns
//
//			// Generate different combinations of turn centers
//			List<List<Vector>> turnCenterCombinations = new ArrayList<List<Vector>>();
//			List<Vector> firstTurnCenters = new ArrayList<Vector>();
//			List<Vector> secondTurnCenters = new ArrayList<Vector>();
//
//			Vector firstTurnBase = orientation.normalizeToLength(R);
//			Vector secondTurnBase = descentStartOrientation.normalizeToLength(R);
//			if (descentStartPosition.toTheRightOf(position, orientation)) {
//				firstTurnCenters.add(position.vectorSum(firstTurnBase.rotateAroundYAxis(-(float)Math.PI/2f)));
//				//firstTurnCenters.add(position.vectorSum(firstTurnBase.rotateAroundYAxis((float)Math.PI/2f)));
//			}else {
//				//firstTurnCenters.add(position.vectorSum(firstTurnBase.rotateAroundYAxis((float)Math.PI/2f)));
//				firstTurnCenters.add(position.vectorSum(firstTurnBase.rotateAroundYAxis(-(float)Math.PI/2f)));
//			}
//
//			if (position.toTheRightOf(descentStartPosition, descentStartOrientation)) {
//				secondTurnCenters.add(descentStartPosition.vectorSum(secondTurnBase.rotateAroundYAxis(-(float)Math.PI/2f)));
//				secondTurnCenters.add(descentStartPosition.vectorSum(secondTurnBase.rotateAroundYAxis((float)Math.PI/2f)));
//			}else {
//				secondTurnCenters.add(descentStartPosition.vectorSum(secondTurnBase.rotateAroundYAxis((float)Math.PI/2f)));
//				secondTurnCenters.add(descentStartPosition.vectorSum(secondTurnBase.rotateAroundYAxis(-(float)Math.PI/2f)));
//			}
//
//			for (Vector firstCenter : firstTurnCenters) {
//				for (Vector secondCenter : secondTurnCenters) {
//					List<Vector> combination = new ArrayList<Vector>();
//					combination.add(firstCenter);
//					combination.add(secondCenter);
//					turnCenterCombinations.add(combination);
//				}
//			}
//
//
//			for (List<Vector> turnCenterCombination : turnCenterCombinations) {
//				// Generate a possible path with given turnCenters
//				Vector firstTurnCenter = turnCenterCombination.get(0);
//				Vector secondTurnCenter = turnCenterCombination.get(1);
//
//				Vector C1C2 = secondTurnCenter.vectorDifference(firstTurnCenter);
//				Vector C2C1 = C1C2.normalizeToLength(-1);
//				float C1C2Length = C1C2.getSize();
//				float theta1 = (float) Math.acos(2f*R/C1C2Length);
//				float theta2 = theta1;
//
//				if (secondTurnCenter.toTheRightOf(descentStartPosition, descentStartOrientation)) {
//					theta2 = -theta2;
//				}
//
//				Vector firstExit = firstTurnCenter.vectorSum(C1C2.normalizeToLength(R).rotateAroundYAxis(theta1));
//				Vector secondEntry = secondTurnCenter.vectorSum(C2C1.normalizeToLength(R).rotateAroundYAxis(theta2));
//
//				if (firstExit.vectorDifference(secondEntry).getSize() >= getMinimumStabilizationDistance()) {
//					// This is a valid path
//					float firstTurnAngle =
//					AutopilotTurn firstTurn = new Turn()
//					break;
//				}
//
//			}
//		}
//
//	}*/
//
//	/**
//	 * Generates the turns the drone should make. Turns are accessible through the method 'getNextTurn'.
//	 * This method will only work properly if the required variables were provided,
//	 * either through the appropriate constructor or through the updateVariables method.
//	 */
//	public void generatePath() {
//
//		getTurns().clear();
//
//		Vector position = getCurrentPosition().makeHorizontal();
//		Vector orientation = getOrientation().makeHorizontal();
//		Vector descentStartPosition = getDescentStartPosition().makeHorizontal();
//		Vector descentStartOrientation = getLandingOrientation().makeHorizontal();
//
//		float R = getStandardRadius();
//
//		// First place the centers of each turn
//		// Select the centers such that the distance between the centers is minimal
//		Vector firstTurnCenter;
//		Vector secondTurnCenter;
//		List<Vector> firstTurnCenters = new ArrayList<Vector>();
//		List<Vector> secondTurnCenters = new ArrayList<Vector>();
//
//		Vector firstTurnBase = orientation.normalizeToLength(R);
//		Vector secondTurnBase = descentStartOrientation.normalizeToLength(R);
//		firstTurnCenters.add(position.vectorSum(firstTurnBase.rotateAroundYAxis(-(float)Math.PI/2f)));
//		firstTurnCenters.add(position.vectorSum(firstTurnBase.rotateAroundYAxis((float)Math.PI/2f)));
//		secondTurnCenters.add(descentStartPosition.vectorSum(secondTurnBase.rotateAroundYAxis(-(float)Math.PI/2f)));
//		secondTurnCenters.add(descentStartPosition.vectorSum(secondTurnBase.rotateAroundYAxis((float)Math.PI/2f)));
//
//		firstTurnCenter = firstTurnCenters.get(0);
//		secondTurnCenter = secondTurnCenters.get(0);
//
//		for (Vector firstCenter : firstTurnCenters) {
//			for (Vector secondCenter : secondTurnCenters) {
//				if (firstCenter.distanceBetween(secondCenter) < firstTurnCenter.distanceBetween(secondTurnCenter)) {
//					firstTurnCenter = firstCenter;
//					secondTurnCenter = secondCenter;
//				}
//			}
//		}
//
//		Vector C1C2 = secondTurnCenter.vectorDifference(firstTurnCenter);
//		float C1C2Length = C1C2.getSize();
//		Vector C1C2Middle = firstTurnCenter.vectorSum(C1C2.scalarMult(0.5f));
//
//		// Determine the exit points for the first turn
//		// There are two possible exit points:
//		//	- Inner: this exit point corresponds to the inner tangent
//		//	- Outer: this exit point corresponds to the outer tangent
//		float angleSign = -1;
//		if (firstTurnCenter.toTheRightOf(position, orientation)) {
//			angleSign = 1;
//		}
//
//		float angle = (float)Math.acos(2*R/C1C2Length);
//
//		Vector firstExitInner = firstTurnCenter.vectorSum(C1C2.normalizeToLength(R).rotateAroundYAxis(angleSign*angle));
//		Vector firstExitOuter = firstTurnCenter.vectorSum(C1C2.normalizeToLength(R).rotateAroundYAxis((float)(angleSign*Math.PI/2f)));
//
//		Vector innerTangent = C1C2Middle.vectorDifference(firstExitInner).scalarMult(2);
//		Vector outerTangent = C1C2;
//
//		// Determine the possible entry points for the second turn
//		// There are two possible entry points:
//		//	- Inner: this entry point corresponds to the inner tangent
//		//	- Outer: this entry point corresponds to the outer tangent
//
//		Vector secondEntryInner = firstExitInner.vectorSum(innerTangent);
//		Vector secondEntryOuter = firstExitOuter.vectorSum(outerTangent);
//
//		// Determine whether the outer or the inner tangent should be selected
//		Vector firstExit;
//		Vector secondEntry;
//		if (secondTurnCenter.toTheRightOf(firstExitOuter, outerTangent) == secondTurnCenter.toTheRightOf(descentStartPosition, descentStartOrientation)) {
//			// Select the outer tangent
//			firstExit = firstExitOuter;
//			secondEntry = secondEntryOuter;
//		}else {
//			// Select the inner tangent
//			firstExit = firstExitInner;
//			secondEntry = secondEntryInner;
//		}
//
//		Vector firstEntry = position;
//		Vector secondExit = descentStartPosition;
//
//		float firstAngle = firstEntry.vectorDifference(firstTurnCenter).getSignedAngleBetween(firstExit.vectorDifference(firstTurnCenter));
//		float secondAngle = secondEntry.vectorDifference(secondTurnCenter).getSignedAngleBetween(secondExit.vectorDifference(secondTurnCenter));
//
//		AutopilotTurn firstTurn = new Turn(firstEntry, firstTurnCenter, firstExit, firstAngle, R);
//		AutopilotTurn secondTurn = new Turn(secondEntry, secondTurnCenter, secondExit, secondAngle, R);
//
//
//		addTurn(firstTurn);
//		addTurn(secondTurn);
//	}
//
//	public List<AutopilotTurn> getTurns(){
//		return this.turns;
//	}
//
//	private void addTurn(AutopilotTurn turn) {
//		this.turns.add(turn);
//	}
//
//	/**
//	 * Returns a turn object corresponding with the next turn the drone should make.
//	 * Returns null if there are no more turns.
//	 * @return
//	 */
//	public AutopilotTurn getNextTurn() {
//
//		if (getTurns().size() == 0) {
//			return null;
//		}
//
//		AutopilotTurn nextTurn = getTurns().get(0);
//		getTurns().remove(0);
//		return nextTurn;
//
//	}
//
//	private float getStandardRadius() {
//		return MINIMUM_RADIUS;
//	}
//
//	private float getLandingAngle() {
//		return LANDING_ANGLE;
//	}
//
//	private float getMinimumStabilizationDistance() {
//		return MINIMUM_STABILIZATION_DISTANCE;
//	}
//
//
//	private List<AutopilotTurn> turns = new ArrayList<AutopilotTurn>();
//
//	private final float MINIMUM_RADIUS = 1000;
//	private final float LANDING_ANGLE = (float)Math.PI/18;
//	private final float MINIMUM_STABILIZATION_DISTANCE = 200;
//
//
//
//
//}
