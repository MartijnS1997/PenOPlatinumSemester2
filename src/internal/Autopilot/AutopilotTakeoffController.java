package internal.Autopilot;

import AutopilotInterfaces.AutopilotConfig;
import AutopilotInterfaces.AutopilotInputs;
import AutopilotInterfaces.AutopilotInputs_v2;
import AutopilotInterfaces.AutopilotOutputs;
import TestbedAutopilotInterface.Overseer.AutopilotDelivery;
import TestbedAutopilotInterface.Overseer.AutopilotInfo;
import internal.Helper.Vector;
import internal.Physics.PhysXEngine;

import java.util.*;
import java.util.logging.Level;

import static java.lang.Math.*;

/**
 * Created by Martijn on 18/02/2018.
 * A class of takeoff controllers, responsible for controlling the takeoff of the drone
 */
public class AutopilotTakeoffController extends Controller {

    public AutopilotTakeoffController(AutoPilot autopilot) {
        super(autopilot);
    }

    /**
     * Getter for the control actions used to steer the drone.
     * first the controller tries to get to the right altitude (the assigned cruising altitude)
     * secondly it tries to stabilize on that altitude
     * @param currentInputs the outputs currently received by the autopilot from the testbed
     * @param previousInputs the inputs previously received by the autopilot from the testbed
     * @return the control outputs needed for a takeoff
     * note that the drone waits for a valid package to deliver if there is no such package the drone will not take off
     */
    @Override
    public AutopilotOutputs getControlActions(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {
        //generate the control outputs
        ControlOutputs outputs = new ControlOutputs(getStandardOutputs());
        //check if it has a package to deliver
        if(!hasPackageToDeliver()){
            //if not, we do not take off yet
            setMaxBrake(outputs);
            return outputs;
        }
        //do the cas control
        CasControls(currentInputs, previousInputs);
        //resume normal controls

        //get the pitch controls
        this.pitchControl(outputs, currentInputs, previousInputs);
        //check for AOA
        this.angleOfAttackControl(getAOAMargin(), outputs, currentInputs, previousInputs);
        //get thrust controls
        this.thrustControl(outputs, currentInputs, previousInputs);
        //return the current outputs
        return outputs;
    }

    /**
     * Adjusts the reference pitch based on the Cas command generated by the collision avoidance system
     * configured for the takeoff controller
     * @param currentInputs the inputs most recently received from the testbed
     * @param previousInputs the inputs previously received from the testbed
     */
    private void CasControls(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {
        TakeoffCAS takeoffCAS = this.getTakeoffCAS();
        CasCommand casCommand = takeoffCAS.getCASCommand(currentInputs, previousInputs);
        setReferencePitch(casCommand);
    }

    @Override
    public void reset() {
        this.getPitchController().reset();
        this.getPitchStabilizerPID().reset();
        this.getThrustController().reset();
    }

    /**
     * Configures the takeoff controller for a single takeoff (we assign the cruising altitude dynamically
     * by calling the autopilot communicator)
     * @param config the configuration to set
     */
    protected void configureController(AutopilotConfig config){
        AutopilotCommunicator communicator = this.getAutopilot().getCommunicator();
        float cruisingAltitude = communicator.getAssignedCruiseAltitude();
        this.setCruisingAltitude(cruisingAltitude);
        this.setConfig(config);
        TakeoffCAS takeoffCAS = new TakeoffCAS(communicator);
        this.setTakeoffCAS(takeoffCAS);
    }

    /**
     * Checks if the drone has any packages to deliver, if not the drone remains idle and does not take off
     * @return true if the drone has a package to deliver
     */
    private boolean hasPackageToDeliver(){
        //get the autopilot
        AutopilotCommunicator communicator = this.getAutopilot().getCommunicator();
        AutopilotDelivery delivery = communicator.getCurrentRequest();
        return delivery != null;
    }

    /**
     * Generates the control actions concerning the pitch of the drone during takeoff
     * @param outputs the outputs to write the result to (this parameter will be modified)
     * @param currentInputs the inputs most recently received from the testbed, used to infer the parameters from
     * @param previousInputs the previous inputs received from the testbed, also used to infer the parameters from
     */
    private void pitchControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
        //get the set point for the pitch
        float referencePitch = this.getReferencePitch();
        //get the current pitch from the inputs
        float currentPitch = Controller.extractPitch(currentInputs);
        //calculate te error
        float errorPitch = referencePitch - currentPitch;
        //get the outputs from the pid controller
        PIDController pitchPid = this.getPitchController();
        float deltaTime = Controller.getDeltaTime(currentInputs, previousInputs);
        //if the reference pitch is larger than the current pitch we have a positive error pitch fed into
        //the PID, the pid will return a negative output --> negative PID output = steer upwards
        //if reference pitch < current pitch, we'll get a negative PID input and a positive output
        //we'll need to steer upwards
        float pidOutputs = pitchPid.getPIDOutput(errorPitch,deltaTime);

        //now calculate the control actions based on the error on the pitch
        //take the linear approach, we want the same inclination of the horizontal stabilizer as the error
        //if possible (first iteration) if we need to go up, negative inclination, if we need to go down
        //positive inclination
        float horizontalInclination = capInclination(pidOutputs, STANDARD_HORIZONTAL, MAX_HORIZONTAL);
        //put it into the outputs
        outputs.setHorStabInclination(horizontalInclination);
    }

    /**
     * Wrapper for the method in the main controller class to regulate the thrust if the velocity
     * to be maintained is stationary (and thus can be controlled by a cruise control)
     * @param outputs the outputs to write the thrust to and read the inclinations from
     * @param currentInputs the most recent inputs from the testbed
     * @param previousInputs the previous inputs from the testbed
     * note: must be invoked only after all the control angles are known because the output inclinations
     *       are used to calculate the thrust needed to acquire the reference velocity
     */
    private void thrustControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
        //get the pid responsible for the trust
        PIDController thrustControl = this.getThrustController();
        //get the reference velocity used by the controller
        float referenceVelocity = this.getReferenceVelocity();
        //check if the reference velocity is already configured
        if(referenceVelocity < 0){
            //calculate the reference velocity
            referenceVelocity = this.getAutopilot().getPhysXOptimisations().calcStableZeroPitchVelocity(STANDARD_MAIN);
            //save the reference velocity
            this.setReferenceVelocity(referenceVelocity);
        }
        //then get the outputs from the standard cruise control implemented in the main controller class
        this.flightCruiseControl(outputs,currentInputs, previousInputs, thrustControl, referenceVelocity);
    }

    private void stabilizePitchControls(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
        //get the pitch difference
        float pitchDiffAngle = this.getRefPitchDiff(currentInputs);
        Vector orientation = Controller.extractOrientation(currentInputs);
        float pitchAngle = -this.getRefPitchDiff(currentInputs);
        //the pitch should be 0;
        //System.out.println(pitch);
        PIDController pitchPid = this.getPitchStabilizerPID();
        float deltaTime = Controller.getDeltaTime(currentInputs, previousInputs);
        float PIDControlActions =  pitchPid.getPIDOutput(pitchAngle,  deltaTime);
        //System.out.println("Pitch result PID" + PIDControlActions);
        //adjust the horizontal stabilizer
        float horizontalInclination = STANDARD_HORIZONTAL - PIDControlActions;
        horizontalInclination = signum(horizontalInclination) * min(abs(horizontalInclination), MAX_HORIZONTAL);
        outputs.setHorStabInclination(horizontalInclination);
    }

    /**
     * Calculates the pitch difference, the angle between the reference vector (the vector between
     * the pitch reference point and the position of the drone) transformed to the drone axis system and
     * projected onto the yz plane in the drone axis system, and the heading vector (0,0,-1) in the drone axis system.
     * The direction is determined by the cross product of the heading vector and the projected and transformed reference
     * vector.
     * @return returns a pos angle if the drone needs to go up, and a negative angle if the drone needs to go down
     */
    private float getRefPitchDiff(AutopilotInputs_v2 currentInputs){
        //get the difference vector
        //get the position of the drone
        Vector dronePos = Controller.extractPosition(currentInputs);
        //get the position of the way point
        Vector pitchRefPoint = this.getPitchReference(currentInputs);
        //get the ref vector
        Vector ref = pitchRefPoint.vectorDifference(dronePos);
        //transform it to the drone axis system
        //first get the current orientation
        Vector orientation = Controller.extractOrientation(currentInputs);
        Vector refDrone = PhysXEngine.worldOnDrone(ref, orientation);
        //then project it onto the yz plane: normal vector (1,0,0)
        Vector normalYZ = new Vector(1,0,0);
        Vector projRefDrone = refDrone.orthogonalProjection(normalYZ);
        //calculate the angle between the heading vector (0,0,-1) and the reference
        Vector headingVect = new Vector(0,0,-1);
        float angle = abs(projRefDrone.getAngleBetween(headingVect));

        //then get the vector product for the direction(the x-component)
        float direction = headingVect.crossProduct(projRefDrone).getxValue();

        float res = angle*signum(direction);
        //check for NaN
        if(Float.isNaN(res)){
            return 0; // NaN comes from the angle
        }
        //else return the result
        return res;

    }

    /**
     * Get the reference point for the pitch used by the takeoff controller
     * @param currentInputs the inputs most recently received from the testbed used to infer the parameters from
     * @return a vector containing a reference point for the drone in the world axis system
     */
    private Vector getPitchReference(AutopilotInputs_v2 currentInputs){
        //get the position & orientation of the drone
        Vector position = extractPosition(currentInputs);
        Vector orientation = extractOrientation(currentInputs);
        float cruisingAltitude = this.getCruisingAltitude();
        //get the relative distance for the reference point (located on the negative z-axis in the
        //heading axis system
        float pitchReferenceDistance = this.getPitchRefDistance();
        Vector refPointHeadingAxis = new Vector(0,0,-pitchReferenceDistance);
        //transform the reference point to the world axis system (relative to drone position)
        Vector refPointWorldAxisRel = PhysXEngine.headingOnWorld(refPointHeadingAxis, orientation);
        //add the x and z position of the drone to the heading vector and there after add
        //the cruising altitude to get the real set point
        Vector relativePos = new Vector(position.getxValue(), cruisingAltitude, position.getzValue());
        Vector refPointWorldAxis = refPointWorldAxisRel.vectorSum(relativePos);

        return refPointWorldAxis;
    }

    /**
     * Checks if the take off controller has reached its current objective
     * @param currentInputs the current inputs (this is the base of the check)
     * @param previousInputs the previous inputs of the autopilot
     * @return true if the current height (y-pos) is larger than or equal to the cruising altitude
     */
    @Override
    public boolean hasReachedObjective(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {
        float cruisingAlt = this.getCruisingAltitude();
        float currentAlt = extractAltitude(currentInputs);
        return currentAlt >= cruisingAlt;
    }


    /**
     * Getter for the cruising altitude of the drone, this is the altitude the drone has to reach
     * during takeoff, the cruising altitude is assigned by the autopilot overseer and may be changed
     * during the simulation
     * @return a float containing the altitude to reach (in meters)
     */
    private float getCruisingAltitude() {
        return cruisingAltitude;
    }

    /**
     * Setter for the cruising altitude, the altitude to reach with the drone during takeoff
     * @param cruisingAltitude the altitude to reach (>0)
     */
    public void setCruisingAltitude(float cruisingAltitude) {
        if(!isValidCruisingAltitude(cruisingAltitude))
            throw new IllegalArgumentException("Invalid cruising altitude, assigned altitude was <= 0");
        this.cruisingAltitude = cruisingAltitude;
    }

    /**
     * Checks if the provided cruising altitude is valid
     * @param cruisingAltitude the cruising altitude to check
     * @return true if and only if cruising altitude > 0;
     */
    private static boolean isValidCruisingAltitude(float cruisingAltitude){
        return cruisingAltitude > 0;
    }

    /**
     * Getter for the reference pitch, the pitch to reach as fast as possible during takeoff to reach the cruising
     * altitude (is used as the set-point for the PID controller responsible for the pitch)
     * @return a float containing the reference pitch range[-PI/2, PI/2]
     */
    private float getReferencePitch() {
        return referencePitch;
    }

    /**
     * Setter for the reference pitch used by the pitch control as the set-point
     * this reference point is determined by the collision avoidance system
     * @param casCommand the command to link the reference pitch to
     */
    public void setReferencePitch(CasCommand casCommand) {
        //create a switch to determine the reference pitch in each of each CAS command
        switch (casCommand){
            case DESCEND:
                this.referencePitch = getDescendRefPitch();
                break;
            default:
                this.referencePitch = getNormalRefpitch();
        }
    }


    /**
     * Getter for the reference pitch in normal flight conditions
     * @return the reference pitch for a normal flight (in radians)
     */
    private static float getNormalRefpitch() {
        return normalRefpitch;
    }


    /**
     * Getter for the reference pitch used for descending if the CAS command requires it
     * @return the reference pitch for a slight descend in radians
     */
    private static float getDescendRefPitch() {
        return descendRefPitch;
    }

    /**
     * Getter for the reference velocity, the velocity that must be reached and maintained by the controller
     * during takeoff
     * @return the velocity (in m/s) to be maintained by the drone
     */
    private float getReferenceVelocity() {
        return referenceVelocity;
    }

    /**
     * Setter for the reference velocity of the controller (for more info see getter)
     * @param referenceVelocity the reference velocity of the drone (must be > 0)
     */
    private void setReferenceVelocity(float referenceVelocity) {
        System.out.println("reference velocity: " + referenceVelocity);
        if(!isValidReferenceVelocity(referenceVelocity)){
            throw new IllegalArgumentException("velocity is not strictly positive");
        }
        this.referenceVelocity = referenceVelocity;
    }

    /**
     * Checks if the provided reference velocity is valid
     * @param referenceVelocity the velocity to check
     * @return true if and only if reference velocity > 0;
     */
    private boolean isValidReferenceVelocity(float referenceVelocity){
        return referenceVelocity > 0;
    }

    /**
     * Getter for the pitch pid controller, the controller used to generate the error measurement
     * for controlling the pitch of the drone, use the reference pitch as a set point for this controller
     * @return the PID controller to be used for the pitch controls
     */
    private PIDController getPitchController() {
        return pitchController;
    }

    /**
     * Getter for the thrust PID controller, the controller to generate the error measurement in velocity
     * used by the cruise control implemented in the main controller class
     * @return a PID controller tuned for the cruise control implemented in de controller class
     */
    private PIDController getThrustController() {
        return thrustController;
    }

    /**
     * Getter for the standard outputs of the controller, used to construct a new control outputs objects
     * @return a standard controls outputs used to construct a new ControlOutputs object, the standard
     *         controls contain default values for the outputs of the controller (such that they don't need to be
     *         bothered with when generating the important control values)
     */
    private StandardOutputs getStandardOutputs() {
        return standardOutputs;
    }

    /**
     * Getter for the distance the reference point is located from the drone in the heading axis
     * @return a float containing the distance from the origin of the drone to the reference point (virtual ref point)
     */
    public float getPitchRefDistance() {
        return pitchRefDistance;
    }

    /**
     * Getter for the error margin on the aoa control calculations
     * @return the margin (in radians)
     */
    public float getAOAMargin() {
        return AOAMargin;
    }

    /**
     * Setter for the error margin on the angle of attack calculations
     * @param AoaMargin the desired error margin
     */
    public void setAOAMargin(float AoaMargin) {
        this.AOAMargin = AoaMargin;
    }

    /**
     * The PID used to stabilize the pitch after a successful takeoff, the drone stabilizes itself
     * so the next controller may have it easier
     * @return the pid tuned to stabilize the pitch of the drone
     */
    private PIDController getPitchStabilizerPID() {
        return pitchStabilizerPID;
    }

    /**
     * Getter for the collision avoidance system used during the takeoff
     * @return the takeoff avoidance system
     */
    private TakeoffCAS getTakeoffCAS() {
        return takeoffCAS;
    }

    /**
     * Setter for the takeoff collision avoidance system
     * @param takeoffCAS the avoidance system used during the takeoff phase
     */
    private void setTakeoffCAS(TakeoffCAS takeoffCAS) {
        this.takeoffCAS = takeoffCAS;
    }

    /**
     * The cruising altitude of the drone used as a milestone to check if we've reached the correct height
     * during the takeoff
     */
    private float cruisingAltitude;

    /**
     * The reference pitch, used during takeoff as a reference to reach for a stable takeoff
     * this pitch should be reached as soon as possible by the autopilot and is used as the error measurement
     * for the PID controller
     */
    private float referencePitch = (float) (15f*PI/180);

    /**
     * The reference pitch in normal conditions
     */
    private final static float normalRefpitch = (float) (15f*PI/180);

    /**
     * The reference pitch in case the CAS command is descend
     */
    private final static float descendRefPitch = (float) (-3f*PI/180);

    /**
     * The reference velocity, used during the takeoff to cap the maxiumum velocity for the next part of the flight
     * (must be fed into the cruise controller as a reference)
     * upon init the value is set to -1f to indicate that the velocity is not yet configured
     * will be set upon first actual call of the controller
     */
    private float referenceVelocity = -1f;

    /**
     * The margin on the angle of attack control used to account for the imperfect approx of the velocity
     * of the drone
     */
    private float AOAMargin = (float) (2*PI/180);

    /**
     * The distance from the drone to the reference pitch point. This point is used by the takeoff controller
     * to stabilize the flight after initialization
     */
    private float pitchRefDistance = 100f;

    /**
     * The collision avoidance system for the takeoff controller
     */
    private TakeoffCAS takeoffCAS;
    /*
    Constants used to steer the drone
     */

    /**
     * Main wing configuration
     * --> standard main, the usual inclination of the main wings
     * --> max inclination delta, the maximum deviation from the standard inclination of the main wings
     */
    private static float STANDARD_MAIN = (float) (5*PI/180);
    private static float MAX_MAIN_DELTA = (float) (2*PI/180);

    /**
     * Horizontal stabilizer configuration
     * --> standard horizontal, the usual inclination of the stabilizer
     * --> max horizontal, the maximum horizontal stabilizer inclination
     */
    private static float STANDARD_HORIZONTAL = 0f;
    private static float MAX_HORIZONTAL = (float) (8f*PI/180f);

    /**
     * Vertical stabilizer configuration
     * --> standard vertical, the usual vertical inclination
     * --> max vertical, the maximum vertical stabilizer inclination
     */
    private static float STANDARD_VERTICAL = 0f;
    private static float MAX_VERTICAL = 0f;

    /**
     * Configuration for the pitch pid controller, responsible for steering the drone upwards during takeoff
     */
    private final static float PITCH_GAIN = 1.0f;
    private final static float PITCH_INTEGRAL = 0.0f;
    private final static float PITCH_DERIVATIVE = 0.0f;
    private PIDController pitchController = new PIDController(PITCH_GAIN, PITCH_INTEGRAL, PITCH_DERIVATIVE);

    /**
     * Configuration for the thrust pid, used by the cruise control provided by the main controller class
     * (we only need to provide the PID we're using for the thrust)
     */
    private final static float THRUST_GAIN = 1.0f;
    private final static float THRUST_INTEGRAL = 0.0f;
    private final static float THRUST_DERIVATIVE = 0.0f;
    private PIDController thrustController = new PIDController(THRUST_GAIN, THRUST_INTEGRAL, THRUST_DERIVATIVE);


    /**
     * The tunings for the PID responsible for stabilizing the pitch of the takeoff controller
     * is invoked before the next controller is invoked, once the pitch is stabilized the next controller is invoked
     */
    private final static float STABLE_PITCH_GAIN = 1.0f;
    private final static float STABLE_PITCH_DERIVATIVE = 0.2f;
    private final static float STABLE_PITCH_INTEGRAL = 0.5f;

    private PIDController pitchStabilizerPID = new PIDController(STABLE_PITCH_GAIN, STABLE_PITCH_INTEGRAL,STABLE_PITCH_DERIVATIVE);


    //standard outputs

    /**
     * The standard outputs for this controller, is used to initialize the control outputs of the drone
     */
    private StandardOutputs standardOutputs = new StandardOutputs() {
        @Override
        public float getStandardRightMainInclination() {
            return STANDARD_MAIN;
        }

        @Override
        public float getStandardLeftMainInclination() {
            return STANDARD_MAIN;
        }

        @Override
        public float getStandardHorizontalStabilizerInclination() {
            return STANDARD_HORIZONTAL;
        }

        @Override
        public float getStandardVerticalStabilizerInclination() {
            return STANDARD_VERTICAL;
        }

        @Override
        public float getStandardThrust() {
            return 0;
        }
    };

    /**
     * An implementation of the CAS for the takeoff controller
     * TODO improve after some testing, this is just rudimentary implementation (maybe needs to be more fine grained)
     */
    private class TakeoffCAS extends CollisionAvoidanceSystem{

        private TakeoffCAS(AutopilotCommunicator communicator) {
            super(communicator);
        }

        @Override
        protected CasCommand getCASCommand(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {
            Vector currentPosition = extractPosition(currentInputs);
            List<AutopilotInfo> threats = new ArrayList<>(this.getThreats(currentPosition));
            //sort the threats --> closest to farthest threats
            threats.sort(getThreatComparator(currentPosition));
            //cycle trough all the threats sorted by distance, we handle the closest one first
            //if the threat doesn't require an action (is not an active threat) handle the next one
            CasCommand command = CasCommand.NOP;
            for(AutopilotInfo threatInfo: threats){
                //handle the threat
                command = handleThreat(currentInputs, threatInfo);
                //if the drone may continue its flight, handle the next threat
                if(command != CasCommand.NOP){
                    break;
                }
            }

            //return the command to handle the closest threat that doesn't require a NOP

            return command;
        }

        /**
         * Threat handler
         * A threat is handled by ascending or descending depending on the type of the threat
         * @param currentInputs the inputs most recently received from the testbed
         * @param threatInfo the info about the threat (needed to handle it)
         * @return the cas command needed to avoid collision
         *         --> if the threat has a higher altitude, the drone descends
         *         --> if the threat has a lower altitude, the drone ascends
         */
        private CasCommand handleThreat(AutopilotInputs_v2 currentInputs, AutopilotInfo threatInfo){
            float currentAltitude = extractAltitude(currentInputs);
            float threatAltitude = threatInfo.getCurrentPosition().getyValue();

            return threatAltitude > currentAltitude ? CasCommand.DESCEND : CasCommand.ASCEND;
        }
    }

}

//    /**
//     * Handles the threat posed by the other drone
//     * this method may only be called if the other drone really causes a threat (eg is closer than the monitor distance)
//     * --> call the getThreads method first
//     * @param currentInputs  the inputs most recently received from the testbed
//     * @param threatInfo  the info about the other drone that is posing a threat
//     * @return the command needed to handle the current threat
//     */
//    private CasCommand handleThreat(AutopilotInputs_v2 currentInputs, AutopilotInfo threatInfo){
//        //for the takeoff controller another drone is an active threat if
//        AutopilotState otherState = threatInfo.getAutopilotState();
//
//        //check if the state of the other drone is a threat state
//        if(!isTakeoffThreatState(otherState)){
//            //we're good, no worries
//            return CasCommand.NOP;
//        }
//
//        //check if the altitude of the threat is lower than the current
//        if(!hasHigherAltitude(currentInputs, threatInfo)){
//            //if so we only need to take action if we're facing downward (pitch < 0)
//            //this case means that we have avoided (a now further) threat by descending
//            return currentInputs.getPitch() < 0 ? CasCommand.ASCEND : CasCommand.DESCEND;
//        }
//
//        //the cases when the threat is at a higher altitude
//        if(isInFrontOfDrone(currentInputs, threatInfo)){
//            //handle the case the threat is in front of the drone
//            return handleInFrontThreat(currentInputs, threatInfo);
//        }else{
//            //handle the case the threat is behind the drone
//            return handleDroneBehindThreat(currentInputs, threatInfo);
//        }
//    }
//
//    /**
//     * Handler for the threat in the case that the other drone is flying behind this drone
//     * @param currentInputs the inputs most recently received by the testbed
//     * @param threatInfo info about the other drone that poses a threat to the caller
//     * @return the command for the controller needed to handle the threat
//     * note: this method may only be called if the other drone that is threatening the current drone
//     *       is flying at a (nearly) constant altitude and is close enough to threaten it
//     */
//    private CasCommand handleDroneBehindThreat(AutopilotInputs_v2 currentInputs, AutopilotInfo threatInfo) {
//        Vector droneHeading = getHeadingVector(currentInputs);
//        //if the drone is not in front of us, it can only pose a threat if the other drone has the same dir
//        return isFlyingInSameDirection(droneHeading, threatInfo) ? CasCommand.MAINTAIN_ALTITUDE : CasCommand.NOP;
//    }
//
//    /**
//     * Handler for the case where the threat is in front of the drone
//     * @param currentInputs the inputs most recently received from the testbed
//     * @param threatInfo info about the other drone that poses a threat
//     * @return the command for the controller needed to handle the threat
//     * note: this method may only be called if the other drone that is threatening the current drone
//     *       is flying at a (nearly) constant altitude and is close enough to threaten it
//     */
//    private CasCommand handleInFrontThreat(AutopilotInputs_v2 currentInputs, AutopilotInfo threatInfo){
//        //if the other drone is in front of us, there are a few possible scenario's
//        //1. the other drone is flying in the same direction --> a steady flight should handle this
//        //2. the other drone is flying towards us --> we should be very wary, maybe even descend a little
//        //   --> this depends on the vicinity of the other drone
//
//        Vector droneHeading = getHeadingVector(currentInputs);
//        Vector currentPos = Controller.extractPosition(currentInputs);
//        Vector otherPos = threatInfo.getCurrentPosition();
//
//        if(isFlyingInSameDirection(droneHeading, threatInfo)) {
//            //handle case 1.
//            return CasCommand.MAINTAIN_ALTITUDE;
//        }
//
//        //handle case 2.
//        //--> this case depends on the vicinity of the other drone, we take an arbitrary threshold
//        float distance = currentPos.distanceBetween(otherPos);
//        return distance < nearCrashDistance ? CasCommand.DESCEND : CasCommand.MAINTAIN_ALTITUDE;
//
//    }
//    /**
//     * Returns true if the provided state could pose a threat to a drone that is taking off and crossing airspace's
//     * @param state the state to check
//     * @return true if the state is a mid-air state and the state is maintaining a steady altitude (and thus
//     * not crossing airspace's)
//     */
//    public boolean isTakeoffThreatState(AutopilotState state){
//        switch(state){
//            case DESCEND_WAIT:
//                return true;
//            case FLIGHT:
//                return true;
//            default:
//                return false;
//        }
//    }
//
//    private final static float nearCrashDistance = 20f;
//}