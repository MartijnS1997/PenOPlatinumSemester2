package internal.Autopilot;

import AutopilotInterfaces.AutopilotInputs_v2;
import AutopilotInterfaces.AutopilotOutputs;

import static internal.Autopilot.AutopilotState.*;
import static java.lang.Math.PI;

/**
 * Created by Martijn on 3/04/2018.
 * The finite state machine describing the behavior of the autopilot during the simulation
 * note: changes since the controller selector
 *       --> the machine does not set inputs for the next controller
 *       --> the machine does not save any inputs for future reference
 */
public class AutopilotFiniteStateMachine {

    /**
     * Constructor for the finite state machine that is responsible for getting the control actions for the drone
     * manages all the controller activity for the autopilot
     * @param autopilot the autopilot the state machine is working for
     */
    public AutopilotFiniteStateMachine(AutoPilot autopilot){
        //create all the controllers
        this.takeoffController = new AutopilotTakeoffController(autopilot);
        this.flightController = new AirportNavigationController(autopilot);
        this.landingController = new AutopilotLandingController(autopilot);
        this.taxiingController = new AutopilotTaxiingController(autopilot);
        this.autopilot = autopilot;

    }

    /**
     * Getter for the outputs of the finite state machine that describes the autopilot
     * @param inputs the current inputs for the state machine
     * @return the control outputs generated by the currently active controller
     */
    public AutopilotOutputs getMachineOutput(AutopilotInputs_v2 inputs){

        //TODO delete once we implemented the controllers, sole purpose of the dummy is to make sure we didn't break stuff
        return new AutopilotOutputs() {
            @Override
            public float getThrust() {
                return 1000;
            }

            @Override
            public float getLeftWingInclination() {
                return (float) (5*PI/180);
            }

            @Override
            public float getRightWingInclination() {
                return (float)(5*PI/180);
            }

            @Override
            public float getHorStabInclination() {
                return (float) (-5*PI/180);
            }

            @Override
            public float getVerStabInclination() {
                return 0;
            }

            @Override
            public float getFrontBrakeForce() {
                return 0;
            }

            @Override
            public float getLeftBrakeForce() {
                return 0;
            }

            @Override
            public float getRightBrakeForce() {
                return 0;
            }
        };

        //TODO uncomment if controllers are implemented
//        //check the state that we should start next
//        AutopilotState activeState = toNextState(inputs);
//        //get the controller that needs to be active
//        Controller controller = this.getStateController(activeState);
//        //get the controller outputs
//        AutopilotOutputs outputs = controller.getControlActions(inputs);
//        //return the result
//        return outputs;
    }


    /**
     * Getter for the state that will be active during the next iteration (not the logically next state)
     * @param inputs the inputs used to determine the next state
     * @return the next active state of the autopilot
     */
    private AutopilotState getNextActiveState(AutopilotInputs_v2 inputs){
        //get the current state
        AutopilotState state = this.getState();
        //determine which controller is next
        switch(state){
            case TAKEOFF:
                //get the takeoff controller
                AutopilotTakeoffController takeoffController = this.getTakeoffController();
                //check if it has reached its objective, if so return the next state, if not continue the takeoff
                return takeoffController.hasReachedObjective(inputs) ? FLIGHT : TAKEOFF;
            case FLIGHT:
                AutopilotFlightController flightController = this.getFlightController();
                //check if the controller has finished doing its job
                return flightController.hasReachedObjective(inputs) ? LANDING : FLIGHT;
            case LANDING:
                AutopilotLandingController landingController = this.getLandingController();
                //check if we're on ground, if not continue landing, otherwise, start taxiing
                return landingController.hasReachedObjective(inputs) ? TAXIING_TO_GATE : LANDING;
            case TAXIING_TO_GATE:
                AutopilotTaxiingController taxiingControllerGate = this.getTaxiingController();
                //check if we've reached the gate, if not keep on going, if so start taxiing to the runway
                return taxiingControllerGate.hasReachedObjective(inputs) ? TAXIING_TO_RUNWAY : TAXIING_TO_GATE;
            case TAXIING_TO_RUNWAY:
                AutopilotTaxiingController taxiingControllerRunway = this.getTaxiingController();
                //check if we've reached the runway, if so start the takeoff, if not keep taxiing
                return taxiingControllerRunway.hasReachedObjective(inputs) ? TAKEOFF : TAXIING_TO_RUNWAY;
            default:
                //Default action, may change later (determine based on the inputs which state should be appropriate
                return TAKEOFF;
        }

    }

    /**
     * Advances the finite state machine to the next state (may the same one as before)
     * while setting the right parameters for each controller
     * @param inputs the inputs to base the configuration on
     * @return the state that needs to be active to generate the next outputs
     * note: may change the configuration of the controllers during the method call (eg targets may be changed)
     */
    private AutopilotState toNextState(AutopilotInputs_v2 inputs){
        //get the next state needed by the controller
        AutopilotState nextState = this.getNextActiveState(inputs);
        //get the previous state
        AutopilotState prevState = this.getState();

        //check if they are the same, if not, configure the controller & save the next state
        if(!nextState.equals(prevState)){
            configureState(nextState, inputs);
            this.setState(nextState);
        }

        //now return the next state
        return nextState;
    }

    /**
     * Configure the controller responsible for the given state
     * @param state the state to configure the controller for
     * @param inputs the inputs used to (partly) configure the controller
     */
    private void configureState(AutopilotState state, AutopilotInputs_v2 inputs){

        switch(state){
            case TAKEOFF:
                configureTakeoff(inputs);
                break;
            case FLIGHT:
                configureFlight(inputs);
                break;
            case LANDING:
                configureLanding(inputs);
                break;
            case TAXIING_TO_GATE:
                configureGateTaxiing(inputs);
                break;
            case TAXIING_TO_RUNWAY:
                configureRunwayTaxiing(inputs);
                break;
        }
    }

    /**
     * Configures the takeoff controller, must be called every time the controller
     * is changed to the takeoff controller (is used to set the new target)
     * @param inputs the inputs  to configure the controller with
     */
    private void configureTakeoff(AutopilotInputs_v2 inputs){
        float cruisingAlt = this.getAutopilot().getCommunicator().getAssignedCruiseAltitude();
        //TODO implement, use the cruising altitude to set the target of the takeoff controller
        //TODO the target may be calculated as the end of the runway or a to reach point or simply an altitude to reach
    }

    /**
     * Configures the flight controller, must be called every time the controller is switched to the
     * flight controller --> used to configure for the flight to the next airport
     * @param inputs the inputs  to configure the controller with
     */
    private void configureFlight(AutopilotInputs_v2 inputs){
        //TODO implement, use the information available on the packages to set the parameters needed to fly to
        //TODO next airport for delivery --> all the info needed is in the autopilot communicator class
        //TODO can be accessed via api chain: this.getAutopilot().getCommunicator();
    }

    /**
     * Configures the landing controller to safely land at the airport at which the next package needs to be delivered
     * @param inputs the inputs  to configure the controller with
     */
    private void configureLanding(AutopilotInputs_v2 inputs){
        //TODO implement, use the landing information contained in the overseer (and the delivery package)
        //TODO to get the right angle for the landing, we may also ship the "get in place" functionality
        //TODO to the flight controller. To access the package use the api chain this.getAutopilot().getCommunicator().getCurrentRequest()
    }

    /**
     * Configures the taxiing controller for the gate taxiing phase, where the drone taxis to the gate where
     * to pick up/deliver the package
     * @param inputs the inputs to configure the controller with
     */
    private void configureGateTaxiing(AutopilotInputs_v2 inputs){
        //TODO implement, set the taxiing target to the gate that needs to be reached to get the package
        //TODO a package is acquired if the drone moves slower than 1m/s and is in a 5m range of the gate
        //TODO use the method setTarget() for the gate taxiing controller (with null for the direction)
        //TODO access the package information via the API chain this.getAutopilot().getCommunicator().getCurrentRequest()
        //TODO get the gate location using the following API chain
        //TODO this.getAutopilot().getCommunicator().getDelivery().getDestinationGate()
        //TODO and then calling the .getAirportByID() in the communicator class

    }

    private void configureRunwayTaxiing(AutopilotInputs_v2 inputs){
        //TODO implement, set the taxiing target to the runway to takeoff to the next airport
        //TODO first acquire the takeoff direction from the overseer and then get in position
        //TODO set the target of the taxiing controller with setTarget(RunwayPos, Direction) so that
        //TODO the taxiing controller knows in which direction to stand for takeoff
        //TODO get the current airport to configure for by the following API chain:
        //TODO this.getAutopilot().getCommunicator().getAirportAtLocation();
    }

    /**
     * Getter for the state that is the next in the row for the finite state machine, does only provide
     * the state that follows the provided state. Does not determine what the next state should be
     * @param state the state to find the successor for
     * @return the state that succeeds the provided state
     */
    private AutopilotState successorState(AutopilotState state){
        switch(state){
            case TAKEOFF:
                return FLIGHT;
            case FLIGHT:
                return LANDING;
            case LANDING:
                return TAXIING_TO_GATE;
            case TAXIING_TO_GATE:
                return TAXIING_TO_RUNWAY;
            case TAXIING_TO_RUNWAY:
                return TAKEOFF;
            default:
                return TAKEOFF;
        }
    }

    /**
     * Get the controller responsible for the provided state
     * @param state the state to get the controller for
     * @return the controller assiciated with the state
     */
    private Controller getStateController(AutopilotState state){
        switch(state){
            case TAKEOFF:
                return this.getTakeoffController();
            case FLIGHT:
                return this.getFlightController();
            case LANDING:
                return this.getLandingController();
            case TAXIING_TO_GATE:
                return this.getTaxiingController();
            case TAXIING_TO_RUNWAY:
                return this.getTaxiingController();
        }

        return null;
    }


    /**
     * Getter for the takeoff controller, the controller that is responsible for guiding
     * the drone's takeoff
     * @return the controller used to guide the takeoff
     */
    private AutopilotTakeoffController getTakeoffController() {
        return takeoffController;
    }

    /**
     * Getter for the flight controller, the controller that is responsible for guiding the
     * drone's flight to the next airport
     * @return the controller to guide the flight
     */
    private AutopilotFlightController getFlightController() {
        return flightController;
    }

    /**
     * Getter for the landing controller, the controller that is responsible for guiding the
     * drone's landing on the target airport
     * @return the controller to guide the landing of the drone
     */
    private AutopilotLandingController getLandingController() {
        return landingController;
    }

    /**
     * Getter for the taxiing controller, the controller that guides the drone during the taxiing phase
     * used for two actions, first getting to the gate (while staying on the tarmac) and second
     * getting into position for takeoff
     * @return the contoller to guide the taxiing of the drone
     */
    private AutopilotTaxiingController getTaxiingController() {
        return taxiingController;
    }

    /**
     * Getter for the autopilot that is represented by the finite state machine
     * @return the autopilot the finite state machine is working for
     */
    private AutoPilot getAutopilot() {
        return autopilot;
    }

    /**
     * Getter for the current state of the machine
     * @return the current state of the autopilot
     */
    private AutopilotState getState() {
        return state;
    }

    /**
     * Setter for the state of the machine
     * @param state the state to assign the autopilot
     */
    private void setState(AutopilotState state) {
        this.state = state;
    }

    /**
     * The state of the finite state machine, is initialized on takeoff
     */
    private AutopilotState state = AutopilotState.TAKEOFF;

    /**
     * The autopilot wherefore the finite state machine is currenly active
     */
    private AutoPilot autopilot;

    /**
     * The controllers used by the finite state machine to generate the control actions
     */
    private AutopilotTakeoffController takeoffController;
    private AutopilotFlightController flightController;
    private AutopilotLandingController landingController;
    private AutopilotTaxiingController taxiingController;

}
