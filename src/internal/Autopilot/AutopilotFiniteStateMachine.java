package internal.Autopilot;

import AutopilotInterfaces.AutopilotConfig;
import AutopilotInterfaces.AutopilotInputs_v2;
import AutopilotInterfaces.AutopilotOutputs;
import TestbedAutopilotInterface.Overseer.MapAirport;
import internal.Helper.Vector;

import static internal.Autopilot.AutopilotState.*;

/**
 * Created by Martijn on 3/04/2018.
 * The finite state machine describing the behavior of the autopilot during the simulation
 * note: changes since the controller selector
 *       --> the machine does not set inputs for the next controller
 *       --> the machine does not save any inputs for future reference
 */
public class AutopilotFiniteStateMachine {

    /**
     * Constructor for the finite state machine that is responsible for getting the control actions for the drone
     * manages all the controller activity for the autopilot
     * @param autopilot the autopilot the state machine is working for
     */
    public AutopilotFiniteStateMachine(AutoPilot autopilot){
        //create all the controllers
        this.takeoffController = new AutopilotTakeoffController(autopilot);
        this.flightController = new AirportNavigationController(autopilot);
        this.landingController = new AutopilotLandingController(autopilot);
        this.taxiingController = new AutopilotTaxiingController(autopilot);
        this.autopilot = autopilot;

    }

    /**
     * Getter for the outputs of the finite state machine that describes the autopilot
     * @param currentInputs the current inputs for the state machine, will also be saved for the next iteration
     * @return the control outputs generated by the currently active controller
     */
    public AutopilotOutputs getMachineOutput(AutopilotInputs_v2 currentInputs){
        //TODO uncomment if controllers are implemented
        //check the state that we should start next
        AutopilotState activeState = toNextState(currentInputs);
        //get the controller that needs to be active
        Controller controller = this.getStateController(activeState);
        //get the controller outputs
        AutopilotInputs_v2 previousInputs = this.getPreviousInputs();
        AutopilotOutputs outputs = controller.getControlActions(currentInputs, previousInputs);
        //save the inputs for the next round
        this.updatePreviousOutputs(currentInputs);
        //return the result
        return outputs;
    }

    //
//        //TODO delete once we implemented the controllers, sole purpose of the dummy is to make sure we didn't break stuff
//        return new AutopilotOutputs() {
//            @Override
//            public float getThrust() {
//                return 1000;
//            }
//
//            @Override
//            public float getLeftWingInclination() {
//                return (float) (5*PI/180);
//            }
//
//            @Override
//            public float getRightWingInclination() {
//                return (float)(5*PI/180);
//            }
//
//            @Override
//            public float getHorStabInclination() {
//                return (float) (-5*PI/180);
//            }
//
//            @Override
//            public float getVerStabInclination() {
//                return 0;
//            }
//
//            @Override
//            public float getFrontBrakeForce() {
//                return 0;
//            }
//
//            @Override
//            public float getLeftBrakeForce() {
//                return 0;
//            }
//
//            @Override
//            public float getRightBrakeForce() {
//                return 0;
//            }
//        };



    /**
     * Getter for the state that will be active during the next iteration (not the logically next state)
     * @param inputs the inputs used to determine the next state
     * @return the next active state of the autopilot
     */
    private AutopilotState getNextActiveState(AutopilotInputs_v2 inputs){
        //get the current state
        AutopilotState state = this.getState();
        //get the previous inputs
        AutopilotInputs_v2 previousInputs = this.getPreviousInputs();
        //determine which controller is next
        switch(state){
            case INIT_FLIGHT:
                //check if we've already passed a single iteration (needed to configure the autopilot)
                return this.getInitController().hasReachedObjective(inputs, previousInputs) ? TAKEOFF : INIT_FLIGHT;
            case TAKEOFF:
                //get the takeoff controller
                AutopilotTakeoffController takeoffController = this.getTakeoffController();
                //check if it has reached its objective, if so return the next state, if not continue the takeoff
                return takeoffController.hasReachedObjective(inputs, previousInputs ) ? FLIGHT : TAKEOFF;
            case FLIGHT:
                AutopilotFlightController flightController = this.getFlightController();
                //check if the controller has finished doing its job
                return flightController.hasReachedObjective(inputs, previousInputs) ? LANDING : FLIGHT;
            case LANDING:
                AutopilotLandingController landingController = this.getLandingController();
                //check if we're on ground, if not continue landing, otherwise, start taxiing
                return landingController.hasReachedObjective(inputs, previousInputs) ? TAXIING_TO_GATE : LANDING;
            case TAXIING_TO_GATE:
                AutopilotTaxiingController taxiingControllerGate = this.getTaxiingController();
                //check if we've reached the gate, if not keep on going, if so start taxiing to the runway
                return taxiingControllerGate.hasReachedObjective(inputs, previousInputs) ? TAXIING_TO_RUNWAY : TAXIING_TO_GATE;
            case TAXIING_TO_RUNWAY:
                AutopilotTaxiingController taxiingControllerRunway = this.getTaxiingController();
                //check if we've reached the runway, if so start the takeoff, if not keep taxiing
                return taxiingControllerRunway.hasReachedObjective(inputs, previousInputs) ? TAKEOFF : TAXIING_TO_RUNWAY;
            default:
                //Default action, may change later (determine based on the inputs which state should be appropriate
                return TAKEOFF;
        }

    }

    /**
     * Advances the finite state machine to the next state (may be the same one as before)
     * while setting the right parameters for each controller
     * @param inputs the inputs to base the configuration on
     * @return the state that needs to be active to generate the next outputs
     * note: may change the configuration of the controllers during the method call (eg targets may be changed)
     * note: usecase --> should be called every iteration to get the next state
     */
    private AutopilotState toNextState(AutopilotInputs_v2 inputs){
        //get the next state needed by the controller
        AutopilotState nextState = this.getNextActiveState(inputs);
        //get the previous state
        AutopilotState prevState = this.getState();

        //check if they are the same, if not, configure the controller & save the next state
        if(!nextState.equals(prevState)){
            configureState(nextState, inputs);
            this.setState(nextState);
            System.out.println("Switched states, from " + AutopilotState.getString(prevState) +
                    ", to " + AutopilotState.getString(nextState));
        }

        //now return the next state
        return nextState;
    }

    /**
     * Configure the controller responsible for the given state
     * @param state the state to configure the controller for
     * @param inputs the inputs used to (partly) configure the controller
     * note: doesn't do any configuring when receiving init state
     */
    private void configureState(AutopilotState state, AutopilotInputs_v2 inputs){

        switch(state){
            case TAKEOFF:
                configureTakeoff(inputs);
                break;
            case FLIGHT:
                configureFlight(inputs);
                break;
            case LANDING:
                configureLanding(inputs);
                break;
            case TAXIING_TO_GATE:
                configureGateTaxiing(inputs);
                break;
            case TAXIING_TO_RUNWAY:
                configureRunwayTaxiing(inputs);
                break;
        }
    }

    /**
     * Configures the takeoff controller, must be called every time the controller
     * is changed to the takeoff controller (is used to set the new target)
     * @param inputs the inputs  to configure the controller with
     */
    private void configureTakeoff(AutopilotInputs_v2 inputs){
        //set the cruising altitude
        float cruisingAlt = this.getAutopilot().getCommunicator().getAssignedCruiseAltitude();
        System.out.println("Assigned altitude for this flight: " + cruisingAlt);
        AutopilotTakeoffController takeoffController = this.getTakeoffController();
        takeoffController.setCruisingAltitude(cruisingAlt);

        //set the config for the controller
        AutopilotConfig config = this.getAutopilot().getConfig();
        takeoffController.setConfig(config);
    }

    /**
     * Configures the flight controller, must be called every time the controller is switched to the
     * flight controller --> used to configure for the flight to the next airport
     * @param inputs the inputs  to configure the controller with
     */
    private void configureFlight(AutopilotInputs_v2 inputs){
        //TODO implement, use the information available on the packages to set the parameters needed to fly to
        //TODO next airport for delivery --> all the info needed is in the autopilot communicator class
        //TODO can be accessed via api chain: this.getAutopilot().getCommunicator();
    }

    /**
     * Configures the landing controller to safely land at the airport at which the next package needs to be delivered
     * @param inputs the inputs  to configure the controller with
     */
    private void configureLanding(AutopilotInputs_v2 inputs){
    	//Set airport where to land
    	int airportID = this.getAutopilot().getCommunicator().getCurrentRequest().getDestinationAirport();
    	MapAirport airport = this.getAutopilot().getCommunicator().getAirportByID(airportID);
    	AutopilotLandingController landingController = this.getLandingController();
    	landingController.setAirport(airport);
    	//Set configuration of the autopilot
    	AutopilotConfig config = this.getAutopilot().getConfig();
        landingController.setConfig(config);
        //TODO implement, use the landing information contained in the overseer (and the delivery package)
        //TODO to get the right angle for the landing, we may also ship the "get in place" functionality
        //TODO to the flight controller. To access the package use the api chain this.getAutopilot().getCommunicator().getCurrentRequest()
    }

    /**
     * Configures the taxiing controller for the gate taxiing phase, where the drone taxis to the gate where
     * to pick up/deliver the package
     * @param inputs the inputs to configure the controller with
     */
    private void configureGateTaxiing(AutopilotInputs_v2 inputs){
        //TODO implement, set the taxiing target to the gate that needs to be reached to get the package
        //TODO a package is acquired if the drone moves slower than 1m/s and is in a 5m range of the gate
        //TODO use the method setTarget() for the gate taxiing controller (with null for the direction)
        //TODO access the package information via the API chain this.getAutopilot().getCommunicator().getCurrentRequest()
        //TODO get the gate location using the following API chain
        //TODO this.getAutopilot().getCommunicator().getDelivery().getDestinationGate()
        //TODO and then calling the .getAirportByID() in the communicator class

    }

    private void configureRunwayTaxiing(AutopilotInputs_v2 inputs){
        //TODO implement, set the taxiing target to the runway to takeoff to the next airport
        //TODO first acquire the takeoff direction from the overseer and then get in position
        //TODO set the target of the taxiing controller with setTarget(RunwayPos, Direction) so that
        //TODO the taxiing controller knows in which direction to stand for takeoff
        //TODO get the current airport to configure for by the following API chain:
        //TODO this.getAutopilot().getCommunicator().getAirportAtLocation();
    }

    /**
     * Getter for the state that is the next in the row for the finite state machine, does only provide
     * the state that follows the provided state. Does not determine what the next state should be
     * --> only for reference
     * @param state the state to find the successor for
     * @return the state that succeeds the provided state
     */
    private AutopilotState successorState(AutopilotState state){
        switch(state){
            case INIT_FLIGHT:
                return TAKEOFF;
            case TAKEOFF:
                return FLIGHT;
            case FLIGHT:
                return LANDING;
            case LANDING:
                return TAXIING_TO_GATE;
            case TAXIING_TO_GATE:
                return TAXIING_TO_RUNWAY;
            case TAXIING_TO_RUNWAY:
                return TAKEOFF;
            default:
                return TAKEOFF;
        }
    }

    /**
     * Get the controller responsible for the provided state
     * @param state the state to get the controller for
     * @return the controller assiciated with the state
     */
    private Controller getStateController(AutopilotState state){
        switch(state){
            case INIT_FLIGHT:
                return this.getInitController();
            case TAKEOFF:
                return this.getTakeoffController();
            case FLIGHT:
                return this.getFlightController();
            case LANDING:
                return this.getLandingController();
            case TAXIING_TO_GATE:
                return this.getTaxiingController();
            case TAXIING_TO_RUNWAY:
                return this.getTaxiingController();
            default:
                return this.getInitController();
        }
    }


    /**
     * Getter for the initializer controller, this is a dummy controller used to wait one
     * iteration to get the previous state of the world (previous inputs) such that the other controllers
     * can function correctly
     * @return a controller used for initializing the finite state machine
     */
    private Controller getInitController() {
        return initController;
    }

    /**
     * Getter for the takeoff controller, the controller that is responsible for guiding
     * the drone's takeoff
     * @return the controller used to guide the takeoff
     */
    private AutopilotTakeoffController getTakeoffController() {
        return takeoffController;
    }

    /**
     * Getter for the flight controller, the controller that is responsible for guiding the
     * drone's flight to the next airport
     * @return the controller to guide the flight
     */
    private AutopilotFlightController getFlightController() {
        return flightController;
    }

    /**
     * Getter for the landing controller, the controller that is responsible for guiding the
     * drone's landing on the target airport
     * @return the controller to guide the landing of the drone
     */
    private AutopilotLandingController getLandingController() {
        return landingController;
    }

    /**
     * Getter for the taxiing controller, the controller that guides the drone during the taxiing phase
     * used for two actions, first getting to the gate (while staying on the tarmac) and second
     * getting into position for takeoff
     * @return the contoller to guide the taxiing of the drone
     */
    private AutopilotTaxiingController getTaxiingController() {
        return taxiingController;
    }

    /**
     * Getter for the autopilot that is represented by the finite state machine
     * @return the autopilot the finite state machine is working for
     */
    private AutoPilot getAutopilot() {
        return autopilot;
    }

    /**
     * Getter for the current state of the machine
     * @return the current state of the autopilot
     */
    private AutopilotState getState() {
        return state;
    }

    /**
     * Getter for the previously received inputs from the testbed
     * @return an autopilot inputs object previously received by the autopilot
     */
    private AutopilotInputs_v2 getPreviousInputs(){
        return this.previousInputs;
    }

    /**
     * Updates the previous outputs that are saved by the finite state machine (required to call a controller)
     * @param inputs the inputs used to update the previous inputs
     * note: the previous outputs are replaced by the currently provided inputs (name is purely for semantics)
     */
    private void updatePreviousOutputs(AutopilotInputs_v2 inputs){
        this.previousInputs = inputs;
    }

    /**
     * Setter for the state of the machine
     * @param state the state to assign the autopilot
     */
    private void setState(AutopilotState state) {
        this.state = state;
    }

    /**
     * The state of the finite state machine, is initialized on takeoff
     */
    private AutopilotState state = AutopilotState.INIT_FLIGHT;

    /**
     * The autopilot wherefore the finite state machine is currenly active
     */
    private AutoPilot autopilot;

    /**
     * The inputs previously received by the finite state machine
     * these are used to initiate the controllers used by the autopilot after another one was used
     * or when they are used for the first time
     */
    private AutopilotInputs_v2 previousInputs = null;

    /**
     * The controllers used by the finite state machine to generate the control actions
     */
    private AutopilotTakeoffController takeoffController;
    private AutopilotFlightController flightController;
    private AutopilotLandingController landingController;
    private AutopilotTaxiingController taxiingController;

    private Controller initController = new Controller(null) {
        @Override
        public AutopilotOutputs getControlActions(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {
            //create a output that does absolutely nothing, because it is the first iteration
            return new AutopilotOutputs() {
                @Override
                public float getThrust() {
                    return 0;
                }

                @Override
                public float getLeftWingInclination() {
                    return 0;
                }

                @Override
                public float getRightWingInclination() {
                    return 0;
                }

                @Override
                public float getHorStabInclination() {
                    return 0;
                }

                @Override
                public float getVerStabInclination() {
                    return 0;
                }

                @Override
                public float getFrontBrakeForce() {
                    return 0;
                }

                @Override
                public float getLeftBrakeForce() {
                    return 0;
                }

                @Override
                public float getRightBrakeForce() {
                    return 0;
                }
            };
        }

        @Override
        public boolean hasReachedObjective(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {
            return AutopilotFiniteStateMachine.this.previousInputs != null;
        }
    };
}
