package internal.Autopilot;

import AutopilotInterfaces.AutopilotConfig;
import AutopilotInterfaces.AutopilotInputs_v2;
import AutopilotInterfaces.AutopilotOutputs;
import internal.Physics.PhysXEngine;
import internal.Helper.Vector;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static java.lang.Math.*;

/**
 * Created by Martijn on 18/02/2018.
 * A class of controllers
 * TODO handle the first call to a newly used controller such that it doesn't give an AOA exception while approximating
 * TODO the AOA
 *
 * TODO revisit the AOA with the newly found formula's for AOA (may not work because the approx only works for stationary velocity)
 *
 * TODO implement reset mechanism such that controllers can be re-used after their phase is over
 */
public abstract class Controller {

    public Controller(AutoPilot autopilot){
        this.autopilot = autopilot;
    }

    /**
     * Debugging method used to save data to a .txt file
     * @param currentInputs the outputs to write
     */
    protected static void trajectoryLog(AutopilotInputs_v2 currentInputs){
        Vector position = extractPosition(currentInputs);
        String logString = position.getxValue() + ";" + position.getyValue() + ";" + position.getzValue() + "\n";
        try {
            Files.write(Paths.get("trajectoryLog.txt"), logString.getBytes(), StandardOpenOption.APPEND);
        }catch (IOException e) {
            //exception handling left as an exercise for the reader
        }
    }

    /**
     * Debugging method used to save data to a .txt file
     * @param error the error to write to the file
     */
    protected static void errorLog(float error){

        String logString = error + "\n";
        try {
            Files.write(Paths.get("errorLog.txt"), logString.getBytes(), StandardOpenOption.APPEND);
        }catch (IOException e) {
            //exception handling left as an exercise for the reader
        }
    }

    /**
     * Generates the control actions for the autopilot
     * based on the current and the previous inputs
     * @param currentInputs the outputs currently received by the autopilot from the testbed
     * @param previousInputs the inputs previously received by the autopilot from the testbed
     * @return the control actions generated by the controller
     */
    public abstract AutopilotOutputs getControlActions(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs);

    /**
     * Checks if the objective of the current controller has been reached
     * @param currentInputs the current inputs (this is the base of the check)
     * @param previousInputs
     * @return true if the controller is ready with its task
     */
    public abstract boolean hasReachedObjective(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs);


    /*
     * Supplementary control methods
     */

    /**
     * Implements a cruise control method for flight
     * the controller tries to maintain the given velocity by adjusting only the thrust of the drone
     * @param outputs the outputs for the drone to write the thrust to & read the inclinations from, needed
     *                to calculate the forces exerted on the wings
     * @param currentInputs the newest inputs received by the autopilot
     * @param previousInputs  the previous inputs received by the autopilot
     * @param cruisePID the PID controller to use for the cruise control (set point should be 0)
     * @param referenceVelocity  the control velocity to reach
     * note: this method should be called after the wing inclinations are known, because they will be used
     *       by the cruise control to calculate the needed thrust
     */
    protected void flightCruiseControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs, PIDController cruisePID, float referenceVelocity){
        //get an approx of the size of the current velocity
        float velocityApprox = getVelocityApprox(currentInputs, previousInputs).getSize();
        //get the time step
        float deltaTime = getDeltaTime(currentInputs, previousInputs);
        //calculate the error value with the pid controller
        float velocityError = referenceVelocity - velocityApprox;
        float PIDOutput = cruisePID.getPIDOutput(velocityError, deltaTime);

        //calculate the control actions
        float requiredThrust = calcRequiredThrust(outputs,currentInputs, previousInputs, PIDOutput);
//        System.out.println("Required thrust: " + requiredThrust);
        //set to the possible thrust
        float thrust  = this.capThrust(requiredThrust);
        //write the calculated thrust to the outputs
        outputs.setThrust(thrust);
    }

    /**
     * Calculates the thrust required to bring the velocity error to zero during the next time step
     * @param outputs the outputs containing the inclinations of the wings needed for the calculation
     * @param currentInputs the latest inputs from the testbed to infer the required variables from
     * @param previousInputs the previous inputs from the testbed to infer the required variables from
     * @param velocityError the error on the velocity to bring to zero
     * @return the required thrust to bring the velocity error to zero on the next iteration
     * note the thrust is not yet capped against the possible, invoke method capThrust afterwards
     */
    private float calcRequiredThrust(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs, float velocityError){
        //get the velocity approximation and the rotation approximation + extract the current orientation (needed for transformations)
        Vector velocityApprox = getVelocityApprox(currentInputs, previousInputs);
        Vector rotationApprox = getRotationApprox(currentInputs, previousInputs);
        Vector orientation = extractOrientation(currentInputs);

        //get the physics engine employed by the autopilot
        PhysXEngine engine = this.getAutopilot().getPhysXEngine();

        //calculate the forces working in on the drone
        Vector airborneForces = engine.getAirborneForces(orientation, rotationApprox, velocityApprox, outputs);

        //transform the forces to the drone axis system
        Vector droneAxisAirborneForces = PhysXEngine.worldOnDrone(airborneForces, orientation);

        //get the z-component, since that is the force we can only compensate for with adding thrust
        float zAirborneForce = droneAxisAirborneForces.getzValue();


        //now calculate the required thrust to get us up to the required velocity: dv/dt * m - Fz = T
        float deltaTime = getDeltaTime(currentInputs, previousInputs);
        float mass = this.getTotalMass();
        //note that is we need to speed up the airborne force will be positive because of the
        //drone axis system's heading pointing to the negative z-axis, so we need to add
        //the airborne force to the required force.
        //second note: the resulting error will be negative to the inputted one, change sign
        return -mass*velocityError/deltaTime + zAirborneForce;
    }

    /**
     * Sets the desired thrust between the minimum allowed thrust (0) and the maximum allowed thrust
     * (acquired by this.getConfig().getMaxThrust()) if the thrust is between the borders [0, maxThrust]
     * the desired thrust is returned
     * @param desiredThrust the thrust to cap
     */
    private float capThrust(float desiredThrust){
        float minThrust = 0f;
        float maxThrust = this.getConfig().getMaxThrust();

        if(desiredThrust < minThrust){
            return minThrust;
        }
        if(desiredThrust > maxThrust){
            return maxThrust;
        }

        return desiredThrust;
    }

    /**
     * Overwrites the given outputs to stabilize the drone, meaning the controller tries to set the orientation
     * of the drone to (heading, 0,0) this method may be used in between controller usage to stabilize the flight
     * for the next controller (without changing the heading of the drone
     * @param outputs the outputs to write the result to
     * @param currentInputs the inputs most recently received by the autopilot from the testbed
     * @param previousInputs the inputs previously received by the autopilot from the testbed
     */
    private void stabilizeDrone(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
        //TODO implement this method
    }

    /**
     * Methods to keep the roll in check
     * if the roll is to large to the right, start steering left
     * if the roll is to large to the left, start steering right
     * @param outputs the outputs to overwrite if the roll threshold is breached and to read the standard
     *                inclinations from to set the wing inclination to
     */
    protected void rollControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, float rollThreshold){

        float roll = currentInputs.getRoll();

        if(roll >= rollThreshold){
            outputs.setRightWingInclination(-outputs.getStandardOutputs().getStandardRightMainInclination());
        }
        else if(roll <= - rollThreshold){
            outputs.setLeftWingInclination(-outputs.getStandardOutputs().getStandardLeftMainInclination());
        }else{
            // change nothing
        }
    }

    /**
     * Caps the given inclination between the standard inclination with a given deviation
     * the borders of the possible inclinations returned by the method are:
     * range [ standardInclination - maxDeviation, standardInclination + maxDeviation]
     * @param currentInclination the inclination to check
     * @param standardInclination the standard inclination (to superimpose the deviation on)
     * @param maxDeviation the maximum deviation from the max inclination allowed
     * @return see implementation
     */
    protected static float capInclination(float currentInclination, float standardInclination, float maxDeviation){
        //get the upper and lower border of the possible inclinations
        float upperBorder = standardInclination + maxDeviation;
        float lowerBorder = standardInclination - maxDeviation;

        if(currentInclination > upperBorder){
            return upperBorder;
        }
        if(currentInclination < lowerBorder){
            return lowerBorder;
        }

        return currentInclination;
    }

    /**
     * Checks if the current control outputs are realisable under the angle of attack constraint provided
     * by the autopilot configuration. If not the controls are adjusted to fit the constraints
     * @param resultMargin the margin of error used when correcting the inclinations to fit the angle of attack
     *                     if eg. the calculated inclination is 15*PI/180 as a maximum, the new inclination will be set
     *                     to 15*PI/180 - resultMargin
     * @param controlOutputs the control outputs to be checked, these will be changed if the outputs will
     *                       give an AOA exception
     * @param currentInputs the most recent inputs received from the testbed
     * @param previousInputs the previously received inputs from the testbed
     */
    protected void angleOfAttackControl(float resultMargin, ControlOutputs controlOutputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {

        //first check if the current and the previous steps are initialized, if not so delete all control actions
        //and set to standard value
        if (currentInputs == null || previousInputs == null) {
            controlOutputs.reset();
            return;
        }
        //first prepare all the variables
        PhysXEngine.PhysXOptimisations optimisations = this.getAutopilot().getPhysXOptimisations();
        Vector orientation = extractOrientation(currentInputs);
        Vector velocity = getVelocityApprox(currentInputs, previousInputs);
        //System.out.println("Velocity: " + velocity);
        Vector rotation = getRotationApprox(currentInputs, previousInputs);
        float angleOfAttack = this.getConfig().getMaxAOA();

        //change until the controls fit
        boolean stable = false;
//        while(!stable) {
        //keep adjusting the control outputs until we are stable (no controls have been changed by the aoa controls
            stable = AOAControlMainLeft(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
            stable = stable && AOAControlMainRight(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
            stable = stable && AOAControlHorStabilizer(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
            stable = stable && AOAControlVerStabilizer(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
//        }
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlMainLeft(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("Left Main");
        float inclinationBorder1 = optimisations.getMaxLeftMainWingInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxLeftMainWingInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getLeftWingInclination();

        float realisableInclination = setBetween(desiredInclination, inclinationBorder1, inclinationBorder2, resultMargin);

        controlOutputs.setLeftWingInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlMainRight(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("MainRight");
        float inclinationBorder1 = optimisations.getMaxRightMainWingInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxRightMainWingInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getRightWingInclination();

        float realisableInclination = setBetween(desiredInclination, inclinationBorder1, inclinationBorder2, resultMargin);

        controlOutputs.setRightWingInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlHorStabilizer(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("Horizontal stabilizer");
        float inclinationBorder1 = optimisations.getMaxHorStabInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxHorStabInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getHorStabInclination();

        float realisableInclination = setBetween(desiredInclination, inclinationBorder1, inclinationBorder2, resultMargin);

        controlOutputs.setHorStabInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlVerStabilizer(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("Vertical stabilizer");
        float inclinationBorder1 = optimisations.getMaxVerStabInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxVerStabInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getVerStabInclination();

        float realisableInclination = setBetween(desiredInclination, -inclinationBorder1, -inclinationBorder2, resultMargin);

        controlOutputs.setVerStabInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }


    /*
    Helper methods
     */
    //note: account for the fact that the distance between the borders could be smaller than the error margin
    private static float setBetween(float value, float border1, float border2, float errorMargin){
        //first check if the value isn't already between the borders:
        float[] borders = sortValue(border1, border2);
        float lowerBorder = borders[0];
        float upperBorder = borders[1];
        //System.out.println("Lower border: " + lowerBorder*RAD2DEGREE + "; Upper border: " + upperBorder*RAD2DEGREE + "; value: " + value*RAD2DEGREE);
        //check if it is already between the borders
        if(value >= lowerBorder && value <= upperBorder) {
            //System.out.println("Selected value: " + value*RAD2DEGREE);
            return value;
        }


        //if not so, set it between with a given error margin
        //check if the value is closest to the lower border
        if(abs(lowerBorder - value) <= abs(upperBorder - value)){
            //System.out.println("Selected value: " + (lowerBorder - signum(lowerBorder)*errorMargin)*RAD2DEGREE);
            return lowerBorder - signum(lowerBorder)*errorMargin;
        }else{
            //System.out.println("Selected value: " + (upperBorder - signum(upperBorder)*errorMargin)*RAD2DEGREE);
            return upperBorder - signum(upperBorder)*errorMargin;
        }

    }

    /**
     * Sorts the two values
     * @param value1 the first value to be sorted
     * @param value2 the second value to be sorted
     * @return an array of size 2 with the smallest value first and the largest second.
     */
    private static float[] sortValue(float value1, float value2){

        float[] sortedArray = new float[2];
        if(value1 <= value2) {
            sortedArray[0] = value1;
            sortedArray[1] = value2;
        }else{
            sortedArray[0] = value2;
            sortedArray[1] = value1;
        }

        return sortedArray;
    }

    /**
     * Calculates the total mass of the drone
     * @return the total mass of the drone (in kg)
     */
    protected float getTotalMass(){
        AutopilotConfig config = this.getConfig();
        float mainWings = config.getWingMass()*2;
        float stabilizers = config.getTailMass()*2;
        float engine = config.getEngineMass();

        return mainWings + stabilizers + engine;
    }

    /**
     * Calculates the time difference between the two different time steps from the given
     * inputs
     * @return the time elapsed between the last two simulation steps
     */
    protected static float getDeltaTime(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){


        float prevTime = previousInputs.getElapsedTime();
        float currTime = currentInputs.getElapsedTime();

        return currTime - prevTime;
    }

    /**
     * Calculate an approximation of the velocity
     * @param currentInputs the most recent inputs received from the testbed
     * @param previousInputs the previously received inputs from the testbed
     * @return the approximation of the velocity
     * elaboration: see textbook numerical math for derivative methods, the
     * derivative of f(k+1) - f(k-1) / (2*timeStep) has O(h²) correctness
     */
    protected static Vector getVelocityApprox(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){

        float prevTime = previousInputs.getElapsedTime();
        float currentTime = currentInputs.getElapsedTime();

        Vector prevPos = extractPosition(previousInputs);
        Vector currentPos = extractPosition(currentInputs);

        Vector posDiff = currentPos.vectorDifference(prevPos);
        float timeDiff = currentTime - prevTime;

        return posDiff.scalarMult(1/timeDiff);
    }

    /**
     * Approximates the current rotation of the drone based on the old rotations
     * @param currentInputs the most recent inputs received from the testbed
     * @param previousInputs the previously received inputs from the testbed
     * @return an approx for the rotation (first calculate the rotation in heading pitch and roll components
     *         and transform them to the actual rotational components)
     */
    protected static Vector getRotationApprox(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){

        //get the passed time interval
        float prevTime = previousInputs.getElapsedTime();
        float currentTime = currentInputs.getElapsedTime();

        //extract the orientations from the inputs
        Vector prevOrient = extractOrientation(previousInputs);
        Vector currentOrient = extractOrientation(currentInputs);

        Vector orientDiff = currentOrient.vectorDifference(prevOrient);
        float timeDiff = currentTime - prevTime;

        // the given rotation vector is given in heading pitch and roll components
        Vector rotationHPR = orientDiff.scalarMult(1/timeDiff);
        // convert back to the world axis rotation vector
        return PhysXEngine.HPRtoRotation(rotationHPR, currentOrient);
    }


    /**
     * Extractor of the orientation in vector format
     * @param inputs the autopilotInput object containing the current inputs
     * @return a vector containing the orientation of the drone in vector format
     */
    protected static Vector extractOrientation(AutopilotInputs_v2 inputs){
        return new Vector(inputs.getHeading(), inputs.getPitch(), inputs.getRoll());
    }

    /**
     * Extracts the heading from the currently provided inputs
     * wrapper for the inputs.getHeading() method
     * @param inputs the inputs to extract the heading from
     * @return a float containing the heading of the drone
     */
    protected static float extractHeading(AutopilotInputs_v2 inputs){
        return inputs.getHeading();
    }

    /**
     * Extracts the pitch from the currently provided inputs
     * wrapper for the inputs.getPitch() method
     * @param inputs the inputs to extract the pitch from
     * @return a float containing the pitch
     */
    protected static float extractPitch(AutopilotInputs_v2 inputs){
        return inputs.getPitch();
    }

    /**
     * Extracts the roll from the currently provided inputs
     * wrapper for the inputs.getRoll() method
     * @param inputs the inputs to extract the roll from
     * @return a float containing the roll
     */
    protected static float extractRoll(AutopilotInputs_v2 inputs) {
        return inputs.getRoll();
    }

    /**
     * Extractor of the orientation in vector format
     * @param inputs the autopilotInput object containing the current inputs
     * @return a vector containing the position of the drone in vector format
     */
    protected static Vector extractPosition(AutopilotInputs_v2 inputs){
        return new Vector(inputs.getX(), inputs.getY(), inputs.getZ());
    }

    /**
     * Wrapper method for inputs.getY()
     * @param inputs the inputs to extract the altitude from
     * @return the altitude of the provided inputs
     */
    protected static float extractAltitude(AutopilotInputs_v2 inputs){
        return inputs.getY();
    }

    /**
     * extracts the x-z coordinates of the drone from the inputs
     * these are the coordinates of the drone in the xz-plane for y=0 (the ground)
     * @param inputs the inputs to extract the ground position from
     * @return a vector containing the x and z coordinates specified in the input
     *         the format = vector(inputs.getX(), 0, inputs.getZ())
     */
    protected static Vector extractGroundPosition(AutopilotInputs_v2 inputs){
        return new Vector(inputs.getX(), 0, inputs.getZ());
    }

    /**
     * Extracts a list of vectors (representing the path) from the list of vectors
     * @param path the path to convert to a list of vectors
     * @return a list containing vectors with the locations of the path objects
     */
    protected static List<Vector> extractPath(AutopilotInterfaces.Path path){

        float xPath[] = path.getX();
        float yPath[] = path.getY();
        float zPath[] = path.getZ();

        // map the path to a list
        List<Vector> pathList = IntStream.range(0, xPath.length)
                .mapToObj(i -> new Vector(xPath[i], yPath[i], zPath[i]))
                .collect(Collectors.toList());

        return pathList;
    }


    /**
     * Getter for the autopilot of the drone
     * @return the autopilot
     */
    protected AutoPilot getAutopilot() {
        return autopilot;
    }


    /**
     * Getter for the configuration of the drone
     * @return the configuration
     */
    protected AutopilotConfig getConfig() {
        return config;
    }

    /**
     * Setter for the configuration
     */
    protected void setConfig(AutopilotConfig config){
        this.config = config;
    }
    
    /**
     * Object that stores the autopilot of the drone
     */
    private AutoPilot autopilot;

    /**
     * Object that stores the configuration of the drone
     */
    private AutopilotConfig config;


    /**
     * Constant used to convert radians to degree
     */
    private final static float RAD2DEGREE = (float) (180/PI);

    /**
     * An implementation of AutopilotOutputs used in the controller for cascading control (passes trough the basic
     * controller, roll control and AOA controll)
     */
    class ControlOutputs implements AutopilotOutputs{

        /**
         * Generates a control outputs with the provided standard inputs, these are used to initialize the outputs
         * and to revert to if the controls are reset
         * @param standardOutputs the standard outputs used upon reset and when no changes to the outputs
         *                        were applied
         */
        ControlOutputs(StandardOutputs standardOutputs){
            //do nothing, everything stays initialized on zero
            this.standardOutputs = standardOutputs;
            this.rightWingInclination = standardOutputs.getStandardRightMainInclination();
            this.leftWingInclination = standardOutputs.getStandardLeftMainInclination();
            this.horStabInclination = standardOutputs.getStandardHorizontalStabilizerInclination();
            this.verStabInclination = standardOutputs.getStandardVerticalStabilizerInclination();
            this.thrust = standardOutputs.getStandardThrust();
            this.frontBrakeForce = standardOutputs.getStandardFrontBrakeForce();
            this.leftBrakeForce = standardOutputs.getStandardLeftBrakeForce();
            this.rightBrakeForce = standardOutputs.getStandardRightBrakeForce();
        }

        /**
         * Default constructor, initializes all the outputs on zero
         */
        ControlOutputs(){
            this(new StandardOutputs() {
                @Override
                public float getStandardRightMainInclination() {
                    return 0;
                }

                @Override
                public float getStandardLeftMainInclination() {
                    return 0;
                }

                @Override
                public float getStandardHorizontalStabilizerInclination() {
                    return 0;
                }

                @Override
                public float getStandardVerticalStabilizerInclination() {
                    return 0;
                }

                @Override
                public float getStandardThrust() {
                    return 0;
                }
            });
        }

        /**
         * gets a deep deepCopy of the given output instance
         * @return the deepCopy
         */
        public ControlOutputs copy(){
            ControlOutputs copy = new ControlOutputs();
            copy.setRightWingInclination(this.getRightWingInclination());
            copy.setLeftWingInclination(this.getLeftWingInclination());
            copy.setHorStabInclination(this.getHorStabInclination());
            copy.setVerStabInclination(this.getVerStabInclination());
            copy.setThrust(this.getThrust());
            copy.setFrontBrakeForce(this.getFrontBrakeForce());
            copy.setLeftBrakeForce(this.getLeftBrakeForce());
            copy.setRightBrakeForce(this.getRightBrakeForce());

            return copy;
        }

        /**
         * Cap all the inclinations of the control outputs
         * the inclinations are set within range [standardValue - delta, standardValue + delta]
         * @param leftWingDelta the max deviation on the left wing inclination
         * @param rightWingDelta the max deviation on the right wing inclination
         * @param horizontalDelta the max deviation on the horizontal stabilizer inclination
         * @param verticalDelta the max deviation on the vertical stabilizer inclination
         */
        protected void capInclinations(float leftWingDelta, float rightWingDelta, float horizontalDelta, float verticalDelta){
            float leftIncl = this.getLeftWingInclination();
            float rightIncl = this.getRightWingInclination();
            float horizontalIncl = this.getHorStabInclination();
            float verticalIncl = this.getVerStabInclination();

            StandardOutputs standardOutputs = this.getStandardOutputs();

            float standardLeft = standardOutputs.getStandardLeftMainInclination();
            float standardRight = standardOutputs.getStandardRightMainInclination();
            float standardHorizontal = standardOutputs.getStandardHorizontalStabilizerInclination();
            float standardVertical = standardOutputs.getStandardVerticalStabilizerInclination();

            this.setLeftWingInclination(capInclination(leftIncl, standardLeft, leftWingDelta));
            this.setRightWingInclination(capInclination(rightIncl, standardRight, rightWingDelta));
            this.setHorStabInclination(capInclination(horizontalIncl, standardHorizontal, horizontalDelta));
            this.setVerStabInclination(capInclination(verticalIncl, standardVertical, verticalDelta));
        }

        /**
         * Set to default values
         * used to reset the outputs if the controller is not fully initialized
         */
        protected void reset(){

            this.setRightWingInclination(getStandardOutputs().getStandardRightMainInclination());
            this.setLeftWingInclination(getStandardOutputs().getStandardLeftMainInclination());
            this.setHorStabInclination(getStandardOutputs().getStandardHorizontalStabilizerInclination());
            this.setVerStabInclination(getStandardOutputs().getStandardVerticalStabilizerInclination());
            this.setFrontBrakeForce(getStandardOutputs().getStandardFrontBrakeForce());
            this.setLeftBrakeForce(getStandardOutputs().getStandardLeftBrakeForce());
            this.setRightBrakeForce(getStandardOutputs().getStandardRightBrakeForce());
        }

        @Override
        public float getThrust() {
            return this.thrust;
        }

        @Override
        public float getLeftWingInclination() {
            return this.leftWingInclination;
        }

        @Override
        public float getRightWingInclination() {
            return this.rightWingInclination;
        }

        @Override
        public float getHorStabInclination() {
            return this.horStabInclination;
        }

        @Override
        public float getVerStabInclination() {
            return this.verStabInclination;
        }

        @Override
        public float getFrontBrakeForce() {
            return this.frontBrakeForce;
        }

        @Override
        public float getLeftBrakeForce() {
            return this.leftBrakeForce;
        }

        @Override
        public float getRightBrakeForce() {
            return this.rightBrakeForce;
        }



        public void setLeftBrakeForce(float leftBrakeForce) {
            this.leftBrakeForce = leftBrakeForce;
        }

        public void setRightBrakeForce(float rightBrakeForce) {
            this.rightBrakeForce = rightBrakeForce;
        }


        public void setFrontBrakeForce(float frontBrakeForce) {
            this.frontBrakeForce = frontBrakeForce;
        }

        /**
         * Setter for the Thrust
         * @param thrust the desired thrust
         */
        public void setThrust(float thrust) {
            this.thrust = thrust;
        }

        /**
         * Setter for the left wing inclination
         * @param leftWingInclination the left wing inclination to set
         */
        public void setLeftWingInclination(float leftWingInclination) {
            this.leftWingInclination = leftWingInclination;
        }

        /**
         * Setter for the right wing inclination
         * @param rightWingInclination the desired right wing inclination
         */
        public void setRightWingInclination(float rightWingInclination) {
            this.rightWingInclination = rightWingInclination;
        }

        /**
         * Setter for the horizontal stabilizer inclination
         * @param horStabInclination the desired horizontal stabilizer inclination
         */
        public void setHorStabInclination(float horStabInclination) {
            this.horStabInclination = horStabInclination;
        }

        /**
         * Setter for the vertical stabilizer inclination
         * @param verStabInclination the desired vertical stabilizer inclination
         */
        public void setVerStabInclination(float verStabInclination) {
            this.verStabInclination = verStabInclination;
        }

        /**
         * Getter for the standard outputs of the control outputs, used to replace the tedious methods
         * to be implemented every single time a controller is made
         * @return
         */
        private StandardOutputs getStandardOutputs() {
            return standardOutputs;
        }

        //initialize the writes to the stable state of the drone
        private StandardOutputs standardOutputs;

        private float thrust;
        private float leftWingInclination;
        private float rightWingInclination;
        private float horStabInclination;
        private float verStabInclination;

        private float leftBrakeForce;
        private float rightBrakeForce;
        private float frontBrakeForce;

        @Override
        public String toString() {
            return "ControlOutputs{" +
                    "thrust=" + thrust +
                    ", leftWingInclination=" + leftWingInclination*RAD2DEGREE +
                    ", rightWingInclination=" + rightWingInclination*RAD2DEGREE +
                    ", horStabInclination=" + horStabInclination*RAD2DEGREE +
                    ", verStabInclination=" + verStabInclination*RAD2DEGREE +
                    ", leftBrakeForce=" + leftBrakeForce +
                    ", rightBrakeForce=" + rightBrakeForce +
                    ", frontBrakeForce=" + frontBrakeForce +
                    '}';
        }
    }


    /**
     * A Class of PID controllers, to be used to calculate control actions for the drone
     */
    class PIDController {
        /**
         * Constructor for a PID controller object
         * @param gainConstant the constant for the gain of de PID controller (also denoted as Kp)
         * @param integralConstant the constant for the integral of the PID controller (also denoted as Ki)
         * @param derivativeConstant the constant for the derivative of the PID controller (also denoted as Kd)
         */
        PIDController(float gainConstant, float integralConstant, float derivativeConstant){
            // set the constants
            this.gainConstant = gainConstant;
            this.integralConstant = integralConstant;
            this.derivativeConstant = derivativeConstant;
        }

        /**
         * Constructs a PID controller with the gain, integral and derivative parameters set to 1.0
         */
        private PIDController(){
            this(1.0f, 1.0f, 1.0f);
        }


        /**
         * Calculates the output for the current inputs of the PID controller
         * @param input the input signal of the controller (from the feedback loop)
         * @param deltaTime the time step between two PID entries
         * @return the output of the PID controller for the given inputs
         * note: algorithm comes from https://en.wikipedia.org/wiki/PID_controller
         */
        float getPIDOutput(float input, float deltaTime){

            // P part is proportional (set to 1)
            // I part reduces overall error
            // D part reduces the oscillation of the path
            // variables needed for calculation
            float setPoint = this.getSetPoint();
            float prevError = this.getPreviousError();
            float integral = this.getIntegral();
            float Kp = this.getGainConstant();
            float Ki = this.getIntegralConstant();
            float Kd = this.getDerivativeConstant();

            //determine the PID control factors
            float error = setPoint - input;
            float derivative = (error - prevError)/deltaTime;
            integral = integral + error*deltaTime;

            // calculate the output
            float output = Kp * error + Ki*integral + Kd*derivative;

            // save the state
            this.setIntegral(integral);
            this.setPreviousError(error);

            return output;
        }

        /**
         * Resets the current PID by setting the integral part to zero
         * so the PID can be reused after some time of de-activation
         */
        public void reset(){
            this.integral = 0;
        }

        /*
        Getters and setters
         */

        /**
         * get the integral part (saved over the course of the algorithm)
         * @return the integral part of the PID
         */
        private float getIntegral() {
            return integral;
        }

        /**
         * set the integral part of the PID (saved over the course of the algorithm)
         */
        private void setIntegral(float integral) {
            this.integral = integral;
        }

        /**
         * get the error of the previous iteration
         */
        private float getPreviousError() {
            return previousError;
        }

        /**
         * Set the previous error (used when the new values for the error are loaded)
         */
        private void setPreviousError(float previousError) {
            this.previousError = previousError;
        }

        /**
         * The set point is the desired value used for reference, in our case it is 0.0
         */
        public float getSetPoint() {
            return setPoint;
        }

        /**
         * Set the set point of the PID
         */
        public void setSetPoint(float setPoint) {
            this.setPoint = setPoint;
        }

        /**
         * Constant used for the gain (proportional) part of the PID
         */
        private float getGainConstant() {
            return gainConstant;
        }

        /**
         * Constant used for the integral part of the PID
         */
        private float getIntegralConstant() {
            return integralConstant;
        }

        /**
         * Constant used for the derivative part of the PID
         */
        private float getDerivativeConstant() {
            return derivativeConstant;
        }

        public void setGainConstant(float gainConstant) {
            this.gainConstant = gainConstant;
        }

        public void setIntegralConstant(float integralConstant) {
            this.integralConstant = integralConstant;
        }

        public void setDerivativeConstant(float derivativeConstant) {
            this.derivativeConstant = derivativeConstant;
        }

        private float integral = 0.0f;
        private float previousError = 0.0f;
        private float setPoint = 0.0f;
        private float gainConstant;
        private float integralConstant;
        private float derivativeConstant;
        private float prevCalcOutput;
    }
}
