package internal.Autopilot;

import AutopilotInterfaces.AutopilotConfig;
import AutopilotInterfaces.AutopilotInputs_v2;
import AutopilotInterfaces.AutopilotOutputs;
import internal.Physics.PhysXEngine;
import internal.Helper.Vector;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static java.lang.Math.*;

/**
 * Created by Martijn on 18/02/2018.
 * A class of controllers
 * TODO handle the first call to a newly used controller such that it doesn't give an AOA exception while approximating
 * TODO the AOA
 *
 * TODO revisit the AOA with the newly found formula's for AOA (may not work because the approx only works for stationary velocity)
 *
 * TODO implement reset mechanism such that controllers can be re-used after their phase is over
 */
public abstract class Controller {

    public Controller(AutoPilot autopilot){
        this.autopilot = autopilot;
    }

    /**
     * Generates the control actions for the autopilot
     * based on the current and the previous inputs
     * @param currentInputs the outputs currently received by the autopilot from the testbed
     * @param previousInputs the inputs previously received by the autopilot from the testbed
     * @return the control actions generated by the controller
     */
    public abstract AutopilotOutputs getControlActions(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs);

    /**
     * Checks if the objective of the current controller has been reached
     * @param currentInputs the current inputs (this is the base of the check)
     * @param previousInputs
     * @return true if the controller is ready with its task
     */
    public abstract boolean hasReachedObjective(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs);


    /**
     * Clears all the state from the controller such that it can be used for a next iteration
     */
    public abstract void reset();


    /**
     * Debugging method used to save data to a .txt file
     * @param currentInputs the outputs to write
     */
    protected static void trajectoryLog(AutopilotInputs_v2 currentInputs){
        Vector position = extractPosition(currentInputs);
        String logString = position.getxValue() + ";" + position.getyValue() + ";" + position.getzValue() + "\n";
        try {
            Files.write(Paths.get("trajectoryLog.txt"), logString.getBytes(), StandardOpenOption.APPEND);
        }catch (IOException e) {
            //exception handling left as an exercise for the reader
        }
    }
    /**
     * Debugging method used to save data to a .txt file
     * @param error the error to write to the file
     */
    protected static void errorLog(float error){

        String logString = error + "\n";
        try {
            Files.write(Paths.get("errorLog.txt"), logString.getBytes(), StandardOpenOption.APPEND);
        }catch (IOException e) {
            //exception handling left as an exercise for the reader
        }
    }

    protected static void vectorErrorLog(Vector errorVector){
        String logString = errorVector.getxValue() + ";" + errorVector.getyValue() + ";" + errorVector.getzValue() + "\n";
        try {
            Files.write(Paths.get("vectorErrorLog.txt"), logString.getBytes(), StandardOpenOption.APPEND);
        }catch (IOException e) {
            //exception handling left as an exercise for the reader
        }
    }

    /**
     * Checks if the two floating point numbers are close enough together
     * to be called "equal" this means the relative error between f1 and f2 is small enough
     * @param f1 the first floating point number
     * @param f2 the second floating point number
     * @return true if the relative error between f1 and f2 is smaller than getEpsilon()
     */
    protected boolean floatEquals(float f1, float f2){
        return Math.abs(f1 - f2)/f1 < getEpsilon();
    }

    /*
     * Supplementary control methods
     */

    /**
     * Implements a cruise control method for flight
     * the controller tries to maintain the given velocity by adjusting only the thrust of the drone
     * @param outputs the outputs for the drone to write the thrust to & read the inclinations from, needed
     *                to calculate the forces exerted on the wings
     * @param currentInputs the newest inputs received by the autopilot
     * @param previousInputs  the previous inputs received by the autopilot
     * @param cruisePID the PID controller to use for the cruise control (set point should be 0)
     * @param referenceVelocity  the control velocity to reach
     * note: this method should be called after the wing inclinations are known, because they will be used
     *       by the cruise control to calculate the needed thrust
     */
    protected void flightCruiseControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs, PIDController cruisePID, float referenceVelocity){
        //get an approx of the size of the current velocity
        float velocityApprox = getVelocityApprox(currentInputs, previousInputs).getSize();
        //get the time step
        float deltaTime = getDeltaTime(currentInputs, previousInputs);
        //calculate the error value with the pid controller
        float velocityError = referenceVelocity - velocityApprox;
        float PIDOutput = cruisePID.getPIDOutput(velocityError, deltaTime);

        //calculate the control actions
        float requiredThrust = calcRequiredThrust(outputs,currentInputs, previousInputs, PIDOutput);
//        System.out.println("Required thrust: " + requiredThrust);
        //set to the possible thrust
        float thrust  = this.capThrust(requiredThrust);
        //write the calculated thrust to the outputs
        outputs.setThrust(thrust);
    }

    /**
     * Calculates the thrust required to bring the velocity error to zero during the next time step
     * @param outputs the outputs containing the inclinations of the wings needed for the calculation
     * @param currentInputs the latest inputs from the testbed to infer the required variables from
     * @param previousInputs the previous inputs from the testbed to infer the required variables from
     * @param velocityError the error on the velocity to bring to zero
     * @return the required thrust to bring the velocity error to zero on the next iteration
     * note the thrust is not yet capped against the possible, invoke method capThrust afterwards
     */
    private float calcRequiredThrust(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs, float velocityError){
        //get the velocity approximation and the rotation approximation + extract the current orientation (needed for transformations)
        Vector velocityApprox = getVelocityApprox(currentInputs, previousInputs);
        Vector rotationApprox = getRotationApprox(currentInputs, previousInputs);
        Vector orientation = extractOrientation(currentInputs);

        //get the physics engine employed by the autopilot
        PhysXEngine engine = this.getAutopilot().getPhysXEngine();

        //calculate the forces working in on the drone
        Vector airborneForces = engine.getAirborneForces(orientation, rotationApprox, velocityApprox, outputs);

        //transform the forces to the drone axis system
        Vector droneAxisAirborneForces = PhysXEngine.worldOnDrone(airborneForces, orientation);

        //get the z-component, since that is the force we can only compensate for with adding thrust
        float zAirborneForce = droneAxisAirborneForces.getzValue();


        //now calculate the required thrust to get us up to the required velocity: dv/dt * m - Fz = T
        float deltaTime = getDeltaTime(currentInputs, previousInputs);
        float mass = this.getTotalMass();
        //note that is we need to speed up the airborne force will be positive because of the
        //drone axis system's heading pointing to the negative z-axis, so we need to add
        //the airborne force to the required force.
        //second note: the resulting error will be negative to the inputted one, change sign
        return -mass*velocityError/deltaTime + zAirborneForce;
    }

    /**
     * Sets the desired thrust between the minimum allowed thrust (0) and the maximum allowed thrust
     * (acquired by this.getConfig().getMaxThrust()) if the thrust is between the borders [0, maxThrust]
     * the desired thrust is returned
     * @param desiredThrust the thrust to cap
     */
    private float capThrust(float desiredThrust){
        float minThrust = 0f;
        float maxThrust = this.getConfig().getMaxThrust();

        if(desiredThrust < minThrust){
            return minThrust;
        }
        if(desiredThrust > maxThrust){
            return maxThrust;
        }

        return desiredThrust;
    }

    /**
     * Overwrites the given outputs to stabilize the drone, meaning the controller tries to set the orientation
     * of the drone to (heading, 0,0) this method may be used in between controller usage to stabilize the flight
     * for the next controller (without changing the heading of the drone
     * @param outputs the outputs to write the result to
     * @param currentInputs the inputs most recently received by the autopilot from the testbed
     * @param previousInputs the inputs previously received by the autopilot from the testbed
     */
    private void stabilizeDrone(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
        //TODO implement this method
    }

    /**
     * Methods to keep the roll in check
     * if the roll is to large to the right, start steering left
     * if the roll is to large to the left, start steering right
     * @param outputs the outputs to overwrite if the roll threshold is breached and to read the standard
     *                inclinations from to set the wing inclination to
     */
    protected void rollControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, float rollThreshold){

        float roll = currentInputs.getRoll();

        if(roll >= rollThreshold){
            outputs.setRightWingInclination(-outputs.getStandardOutputs().getStandardRightMainInclination());
        }
        else if(roll <= - rollThreshold){
            outputs.setLeftWingInclination(-outputs.getStandardOutputs().getStandardLeftMainInclination());
        }else{
            // change nothing
        }
    }

    /**
     * Caps the given inclination between the standard inclination with a given deviation
     * the borders of the possible inclinations returned by the method are:
     * range [ standardInclination - maxDeviation, standardInclination + maxDeviation]
     * @param currentInclination the inclination to check
     * @param standardInclination the standard inclination (to superimpose the deviation on)
     * @param maxDeviation the maximum deviation from the max inclination allowed
     * @return see implementation
     */
    protected static float capInclination(float currentInclination, float standardInclination, float maxDeviation){
        //get the upper and lower border of the possible inclinations
        float upperBorder = standardInclination + maxDeviation;
        float lowerBorder = standardInclination - maxDeviation;

        if(currentInclination > upperBorder){
            return upperBorder;
        }
        if(currentInclination < lowerBorder){
            return lowerBorder;
        }

        return currentInclination;
    }

    /**
     * Checks if the current control outputs are realisable under the angle of attack constraint provided
     * by the autopilot configuration. If not the controls are adjusted to fit the constraints
     * @param resultMargin the margin of error used when correcting the inclinations to fit the angle of attack
     *                     if eg. the calculated inclination is 15*PI/180 as a maximum, the new inclination will be set
     *                     to 15*PI/180 - resultMargin
     * @param controlOutputs the control outputs to be checked, these will be changed if the outputs will
     *                       give an AOA exception
     * @param currentInputs the most recent inputs received from the testbed
     * @param previousInputs the previously received inputs from the testbed
     */
    protected void angleOfAttackControl(float resultMargin, ControlOutputs controlOutputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {

        //first check if the current and the previous steps are initialized, if not so delete all control actions
        //and set to standard value
        if (currentInputs == null || previousInputs == null) {
            controlOutputs.reset();
            return;
        }
        //first prepare all the variables
        PhysXEngine.PhysXOptimisations optimisations = this.getAutopilot().getPhysXOptimisations();
        Vector orientation = extractOrientation(currentInputs);
        Vector velocity = getVelocityApprox(currentInputs, previousInputs);
        //System.out.println("Velocity: " + velocity);
        Vector rotation = getRotationApprox(currentInputs, previousInputs);
        float angleOfAttack = this.getConfig().getMaxAOA();

        //change until the controls fit
        boolean stable = false;
//        while(!stable) {
        //keep adjusting the control outputs until we are stable (no controls have been changed by the aoa controls
            stable = AOAControlMainLeft(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
            stable = stable && AOAControlMainRight(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
            stable = stable && AOAControlHorStabilizer(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
            stable = stable && AOAControlVerStabilizer(controlOutputs, optimisations, angleOfAttack, resultMargin, orientation, rotation, velocity);
//        }
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlMainLeft(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("Left Main");
        float inclinationBorder1 = optimisations.getMaxLeftMainWingInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxLeftMainWingInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getLeftWingInclination();

        float realisableInclination = setBetween(desiredInclination, inclinationBorder1, inclinationBorder2, resultMargin);

        controlOutputs.setLeftWingInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlMainRight(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("MainRight");
        float inclinationBorder1 = optimisations.getMaxRightMainWingInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxRightMainWingInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getRightWingInclination();

        float realisableInclination = setBetween(desiredInclination, inclinationBorder1, inclinationBorder2, resultMargin);

        controlOutputs.setRightWingInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlHorStabilizer(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("Horizontal stabilizer");
        float inclinationBorder1 = optimisations.getMaxHorStabInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxHorStabInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getHorStabInclination();

        float realisableInclination = setBetween(desiredInclination, inclinationBorder1, inclinationBorder2, resultMargin);

        controlOutputs.setHorStabInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }

    /**
     * Checks if the control outputs are realisable under the AOA restrictions, if not change them to fit
     * between the borders of what is allowed.
     * @param controlOutputs the control outputs of the controller
     * @param optimisations the physics optimisations used for the calculations
     * @param angleOfAttack the maximum angle of attack
     * @param orientation the orientation of the drone
     * @param rotation the rotation of the drone (world-axis)
     * @param velocity the velocity of the drone (world-axis)
     * @return true if the controls were changed, false if not
     * @author Martijn Sauwens
     */
    private boolean AOAControlVerStabilizer(ControlOutputs controlOutputs, PhysXEngine.PhysXOptimisations optimisations, float angleOfAttack, float resultMargin, Vector orientation, Vector rotation, Vector velocity){
        //System.out.println("Vertical stabilizer");
        float inclinationBorder1 = optimisations.getMaxVerStabInclination(orientation, rotation, velocity, angleOfAttack);
        float inclinationBorder2 = optimisations.getMaxVerStabInclination(orientation, rotation, velocity, -angleOfAttack);

        float desiredInclination = controlOutputs.getVerStabInclination();

        float realisableInclination = setBetween(desiredInclination, -inclinationBorder1, -inclinationBorder2, resultMargin);

        controlOutputs.setVerStabInclination(realisableInclination);

        return desiredInclination == realisableInclination;
    }


    /*
    Helper methods
     */
    //note: account for the fact that the distance between the borders could be smaller than the error margin
    private static float setBetween(float value, float border1, float border2, float errorMargin){
        //first check if the value isn't already between the borders:
        float[] borders = sortValue(border1, border2);
        float lowerBorder = borders[0];
        float upperBorder = borders[1];
        //System.out.println("Lower border: " + lowerBorder*RAD2DEGREE + "; Upper border: " + upperBorder*RAD2DEGREE + "; value: " + value*RAD2DEGREE);
        //check if it is already between the borders
        if(value >= lowerBorder && value <= upperBorder) {
            //System.out.println("Selected value: " + value*RAD2DEGREE);
            return value;
        }


        //if not so, set it between with a given error margin
        //check if the value is closest to the lower border
        if(abs(lowerBorder - value) <= abs(upperBorder - value)){
            //System.out.println("Selected value: " + (lowerBorder - signum(lowerBorder)*errorMargin)*RAD2DEGREE);
            return lowerBorder - signum(lowerBorder)*errorMargin;
        }else{
            //System.out.println("Selected value: " + (upperBorder - signum(upperBorder)*errorMargin)*RAD2DEGREE);
            return upperBorder - signum(upperBorder)*errorMargin;
        }

    }

    /**
     * Sorts the two values
     * @param value1 the first value to be sorted
     * @param value2 the second value to be sorted
     * @return an array of size 2 with the smallest value first and the largest second.
     */
    private static float[] sortValue(float value1, float value2){

        float[] sortedArray = new float[2];
        if(value1 <= value2) {
            sortedArray[0] = value1;
            sortedArray[1] = value2;
        }else{
            sortedArray[0] = value2;
            sortedArray[1] = value1;
        }

        return sortedArray;
    }

    /**
     * Calculates the total mass of the drone
     * @return the total mass of the drone (in kg)
     */
    protected float getTotalMass(){
        AutopilotConfig config = this.getConfig();
        float mainWings = config.getWingMass()*2;
        float stabilizers = config.getTailMass()*2;
        float engine = config.getEngineMass();

        return mainWings + stabilizers + engine;
    }

    /**
     * Calculates the time difference between the two different time steps from the given
     * inputs
     * @return the time elapsed between the last two simulation steps
     */
    protected static float getDeltaTime(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){


        float prevTime = previousInputs.getElapsedTime();
        float currTime = currentInputs.getElapsedTime();

        return currTime - prevTime;
    }

    /**
     * Calculate an approximation of the velocity
     * @param currentInputs the most recent inputs received from the testbed
     * @param previousInputs the previously received inputs from the testbed
     * @return the approximation of the velocity
     * elaboration: see textbook numerical math for derivative methods, the
     * derivative of f(k+1) - f(k-1) / (2*timeStep) has O(hÂ²) correctness
     */
    protected static Vector getVelocityApprox(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){

        float prevTime = previousInputs.getElapsedTime();
        float currentTime = currentInputs.getElapsedTime();

        Vector prevPos = extractPosition(previousInputs);
        Vector currentPos = extractPosition(currentInputs);

        Vector posDiff = currentPos.vectorDifference(prevPos);
        float timeDiff = currentTime - prevTime;

        return posDiff.scalarMult(1/timeDiff);
    }

    /**
     * Approximates the current rotation of the drone based on the old rotations
     * @param currentInputs the most recent inputs received from the testbed
     * @param previousInputs the previously received inputs from the testbed
     * @return an approx for the rotation (first calculate the rotation in heading pitch and roll components
     *         and transform them to the actual rotational components)
     */
    protected static Vector getRotationApprox(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){

        //get the passed time interval
        float prevTime = previousInputs.getElapsedTime();
        float currentTime = currentInputs.getElapsedTime();

        //extract the orientations from the inputs
        Vector prevOrient = extractOrientation(previousInputs);
        Vector currentOrient = extractOrientation(currentInputs);

        Vector orientDiff = currentOrient.vectorDifference(prevOrient);
        float timeDiff = currentTime - prevTime;

        // the given rotation vector is given in heading pitch and roll components
        Vector rotationHPR = orientDiff.scalarMult(1/timeDiff);
        // convert back to the world axis rotation vector
        return PhysXEngine.HPRtoRotation(rotationHPR, currentOrient);
    }


    /**
     * Extractor of the orientation in vector format
     * @param inputs the autopilotInput object containing the current inputs
     * @return a vector containing the orientation of the drone in vector format
     */
    protected static Vector extractOrientation(AutopilotInputs_v2 inputs){
        return new Vector(inputs.getHeading(), inputs.getPitch(), inputs.getRoll());
    }

    /**
     * Extracts the heading from the currently provided inputs
     * wrapper for the inputs.getHeading() method
     * @param inputs the inputs to extract the heading from
     * @return a float containing the heading of the drone
     */
    protected static float extractHeading(AutopilotInputs_v2 inputs){
        return inputs.getHeading();
    }

    /**
     * Extracts the pitch from the currently provided inputs
     * wrapper for the inputs.getPitch() method
     * @param inputs the inputs to extract the pitch from
     * @return a float containing the pitch
     */
    protected static float extractPitch(AutopilotInputs_v2 inputs){
        return inputs.getPitch();
    }

    /**
     * Extracts the roll from the currently provided inputs
     * wrapper for the inputs.getRoll() method
     * @param inputs the inputs to extract the roll from
     * @return a float containing the roll
     */
    protected static float extractRoll(AutopilotInputs_v2 inputs) {
        return inputs.getRoll();
    }

    /**
     * Extractor of the orientation in vector format
     * @param inputs the autopilotInput object containing the current inputs
     * @return a vector containing the position of the drone in vector format
     */
    protected static Vector extractPosition(AutopilotInputs_v2 inputs){
        return new Vector(inputs.getX(), inputs.getY(), inputs.getZ());
    }

    /**
     * Wrapper method for inputs.getY()
     * @param inputs the inputs to extract the altitude from
     * @return the altitude of the provided inputs
     */
    protected static float extractAltitude(AutopilotInputs_v2 inputs){
        return inputs.getY();
    }

    /**
     * extracts the x-z coordinates of the drone from the inputs
     * these are the coordinates of the drone in the xz-plane for y=0 (the ground)
     * @param inputs the inputs to extract the ground position from
     * @return a vector containing the x and z coordinates specified in the input
     *         the format = vector(inputs.getX(), 0, inputs.getZ())
     */
    protected static Vector extractGroundPosition(AutopilotInputs_v2 inputs){
        return new Vector(inputs.getX(), 0, inputs.getZ());
    }

    /**
     * Extracts a list of vectors (representing the path) from the list of vectors
     * @param path the path to convert to a list of vectors
     * @return a list containing vectors with the locations of the path objects
     */
    protected static List<Vector> extractPath(AutopilotInterfaces.Path path){

        float xPath[] = path.getX();
        float yPath[] = path.getY();
        float zPath[] = path.getZ();

        // map the path to a list
        List<Vector> pathList = IntStream.range(0, xPath.length)
                .mapToObj(i -> new Vector(xPath[i], yPath[i], zPath[i]))
                .collect(Collectors.toList());

        return pathList;
    }


    /**
     * Getter for the autopilot of the drone
     * @return the autopilot
     */
    protected AutoPilot getAutopilot() {
        return autopilot;
    }


    /**
     * Getter for the configuration of the drone
     * @return the configuration
     */
    protected AutopilotConfig getConfig() {
        return config;
    }

    /**
     * Setter for the configuration
     */
    protected void setConfig(AutopilotConfig config){
        this.config = config;
    }

    /**
     * Getter for the epsilon used by the float equals error
     * returns the standard epsilon value defined in the main controller class
     * but may be overwritten if higher accuracy is desired
     * @return the epsilon value used during the float equals calculation
     */
    protected float getEpsilon(){
        return EPSILON;
    }
    
    /**
     * Object that stores the autopilot of the drone
     */
    private AutoPilot autopilot;

    /**
     * Object that stores the configuration of the drone
     */
    private AutopilotConfig config;


    /**
     * Constant used to convert radians to degree
     */
    private final static float RAD2DEGREE = (float) (180/PI);

    /**
     * The epsilon used for the float equals method
     */
    private final static float EPSILON = 5.0E-3f;

    /**
     * An implementation of AutopilotOutputs used in the controller for cascading control (passes trough the basic
     * controller, roll control and AOA controll)
     */
    class ControlOutputs implements AutopilotOutputs{

        /**
         * Generates a control outputs with the provided standard inputs, these are used to initialize the outputs
         * and to revert to if the controls are reset
         * @param standardOutputs the standard outputs used upon reset and when no changes to the outputs
         *                        were applied
         */
        ControlOutputs(StandardOutputs standardOutputs){
            //do nothing, everything stays initialized on zero
            this.standardOutputs = standardOutputs;
            this.rightWingInclination = standardOutputs.getStandardRightMainInclination();
            this.leftWingInclination = standardOutputs.getStandardLeftMainInclination();
            this.horStabInclination = standardOutputs.getStandardHorizontalStabilizerInclination();
            this.verStabInclination = standardOutputs.getStandardVerticalStabilizerInclination();
            this.thrust = standardOutputs.getStandardThrust();
            this.frontBrakeForce = standardOutputs.getStandardFrontBrakeForce();
            this.leftBrakeForce = standardOutputs.getStandardLeftBrakeForce();
            this.rightBrakeForce = standardOutputs.getStandardRightBrakeForce();
        }

        /**
         * Default constructor, initializes all the outputs on zero
         */
        ControlOutputs(){
            this(new StandardOutputs() {
                @Override
                public float getStandardRightMainInclination() {
                    return 0;
                }

                @Override
                public float getStandardLeftMainInclination() {
                    return 0;
                }

                @Override
                public float getStandardHorizontalStabilizerInclination() {
                    return 0;
                }

                @Override
                public float getStandardVerticalStabilizerInclination() {
                    return 0;
                }

                @Override
                public float getStandardThrust() {
                    return 0;
                }
            });
        }

        /**
         * gets a deep deepCopy of the given output instance
         * @return the deepCopy
         */
        public ControlOutputs copy(){
            ControlOutputs copy = new ControlOutputs();
            copy.setRightWingInclination(this.getRightWingInclination());
            copy.setLeftWingInclination(this.getLeftWingInclination());
            copy.setHorStabInclination(this.getHorStabInclination());
            copy.setVerStabInclination(this.getVerStabInclination());
            copy.setThrust(this.getThrust());
            copy.setFrontBrakeForce(this.getFrontBrakeForce());
            copy.setLeftBrakeForce(this.getLeftBrakeForce());
            copy.setRightBrakeForce(this.getRightBrakeForce());

            return copy;
        }

        /**
         * Cap all the inclinations of the control outputs
         * the inclinations are set within range [standardValue - delta, standardValue + delta]
         * @param leftWingDelta the max deviation on the left wing inclination
         * @param rightWingDelta the max deviation on the right wing inclination
         * @param horizontalDelta the max deviation on the horizontal stabilizer inclination
         * @param verticalDelta the max deviation on the vertical stabilizer inclination
         */
        protected void capInclinations(float leftWingDelta, float rightWingDelta, float horizontalDelta, float verticalDelta){
            float leftIncl = this.getLeftWingInclination();
            float rightIncl = this.getRightWingInclination();
            float horizontalIncl = this.getHorStabInclination();
            float verticalIncl = this.getVerStabInclination();

            StandardOutputs standardOutputs = this.getStandardOutputs();

            float standardLeft = standardOutputs.getStandardLeftMainInclination();
            float standardRight = standardOutputs.getStandardRightMainInclination();
            float standardHorizontal = standardOutputs.getStandardHorizontalStabilizerInclination();
            float standardVertical = standardOutputs.getStandardVerticalStabilizerInclination();

            this.setLeftWingInclination(capInclination(leftIncl, standardLeft, leftWingDelta));
            this.setRightWingInclination(capInclination(rightIncl, standardRight, rightWingDelta));
            this.setHorStabInclination(capInclination(horizontalIncl, standardHorizontal, horizontalDelta));
            this.setVerStabInclination(capInclination(verticalIncl, standardVertical, verticalDelta));
        }

        /**
         * Set to default values
         * used to reset the outputs if the controller is not fully initialized
         */
        protected void reset(){

            this.setRightWingInclination(getStandardOutputs().getStandardRightMainInclination());
            this.setLeftWingInclination(getStandardOutputs().getStandardLeftMainInclination());
            this.setHorStabInclination(getStandardOutputs().getStandardHorizontalStabilizerInclination());
            this.setVerStabInclination(getStandardOutputs().getStandardVerticalStabilizerInclination());
            this.setFrontBrakeForce(getStandardOutputs().getStandardFrontBrakeForce());
            this.setLeftBrakeForce(getStandardOutputs().getStandardLeftBrakeForce());
            this.setRightBrakeForce(getStandardOutputs().getStandardRightBrakeForce());
        }

        @Override
        public float getThrust() {
            return this.thrust;
        }

        @Override
        public float getLeftWingInclination() {
            return this.leftWingInclination;
        }

        @Override
        public float getRightWingInclination() {
            return this.rightWingInclination;
        }

        @Override
        public float getHorStabInclination() {
            return this.horStabInclination;
        }

        @Override
        public float getVerStabInclination() {
            return this.verStabInclination;
        }

        @Override
        public float getFrontBrakeForce() {
            return this.frontBrakeForce;
        }

        @Override
        public float getLeftBrakeForce() {
            return this.leftBrakeForce;
        }

        @Override
        public float getRightBrakeForce() {
            return this.rightBrakeForce;
        }



        public void setLeftBrakeForce(float leftBrakeForce) {
            this.leftBrakeForce = leftBrakeForce;
        }

        public void setRightBrakeForce(float rightBrakeForce) {
            this.rightBrakeForce = rightBrakeForce;
        }


        public void setFrontBrakeForce(float frontBrakeForce) {
            this.frontBrakeForce = frontBrakeForce;
        }

        /**
         * Setter for the Thrust
         * @param thrust the desired thrust
         */
        public void setThrust(float thrust) {
            this.thrust = thrust;
        }

        /**
         * Setter for the left wing inclination
         * @param leftWingInclination the left wing inclination to set
         */
        public void setLeftWingInclination(float leftWingInclination) {
            this.leftWingInclination = leftWingInclination;
        }

        /**
         * Setter for the right wing inclination
         * @param rightWingInclination the desired right wing inclination
         */
        public void setRightWingInclination(float rightWingInclination) {
            this.rightWingInclination = rightWingInclination;
        }

        /**
         * Setter for the horizontal stabilizer inclination
         * @param horStabInclination the desired horizontal stabilizer inclination
         */
        public void setHorStabInclination(float horStabInclination) {
            this.horStabInclination = horStabInclination;
        }

        /**
         * Setter for the vertical stabilizer inclination
         * @param verStabInclination the desired vertical stabilizer inclination
         */
        public void setVerStabInclination(float verStabInclination) {
            this.verStabInclination = verStabInclination;
        }

        /**
         * Getter for the standard outputs of the control outputs, used to replace the tedious methods
         * to be implemented every single time a controller is made
         * @return
         */
        private StandardOutputs getStandardOutputs() {
            return standardOutputs;
        }

        //initialize the writes to the stable state of the drone
        private StandardOutputs standardOutputs;

        private float thrust;
        private float leftWingInclination;
        private float rightWingInclination;
        private float horStabInclination;
        private float verStabInclination;

        private float leftBrakeForce;
        private float rightBrakeForce;
        private float frontBrakeForce;

        @Override
        public String toString() {
            return "ControlOutputs{" +
                    "thrust=" + thrust +
                    ", leftWingInclination=" + leftWingInclination*RAD2DEGREE +
                    ", rightWingInclination=" + rightWingInclination*RAD2DEGREE +
                    ", horStabInclination=" + horStabInclination*RAD2DEGREE +
                    ", verStabInclination=" + verStabInclination*RAD2DEGREE +
                    ", leftBrakeForce=" + leftBrakeForce +
                    ", rightBrakeForce=" + rightBrakeForce +
                    ", frontBrakeForce=" + frontBrakeForce +
                    '}';
        }
    }


    /**
     * A Class of PID controllers, to be used to calculate control actions for the drone
     */
    class PIDController {
        /**
         * Constructor for a PID controller object
         * @param gainConstant the constant for the gain of de PID controller (also denoted as Kp)
         * @param integralConstant the constant for the integral of the PID controller (also denoted as Ki)
         * @param derivativeConstant the constant for the derivative of the PID controller (also denoted as Kd)
         */
        PIDController(float gainConstant, float integralConstant, float derivativeConstant){
            // set the constants
            this.gainConstant = gainConstant;
            this.integralConstant = integralConstant;
            this.derivativeConstant = derivativeConstant;
        }

        /**
         * Constructs a PID controller with the gain, integral and derivative parameters set to 1.0
         */
        private PIDController(){
            this(1.0f, 1.0f, 1.0f);
        }


        /**
         * Calculates the output for the current inputs of the PID controller
         * @param input the input signal of the controller (from the feedback loop)
         * @param deltaTime the time step between two PID entries
         * @return the output of the PID controller for the given inputs
         * note: algorithm comes from https://en.wikipedia.org/wiki/PID_controller
         */
        float getPIDOutput(float input, float deltaTime){

            // P part is proportional (set to 1)
            // I part reduces overall error
            // D part reduces the oscillation of the path
            // variables needed for calculation
            float setPoint = this.getSetPoint();
            float prevError = this.getPreviousError();
            float integral = this.getIntegral();
            float Kp = this.getGainConstant();
            float Ki = this.getIntegralConstant();
            float Kd = this.getDerivativeConstant();

            //determine the PID control factors
            float error = setPoint - input;
            float derivative = (error - prevError)/deltaTime;
            integral = integral + error*deltaTime;

            // calculate the output
            float output = Kp * error + Ki*integral + Kd*derivative;

            // save the state
            this.setIntegral(integral);
            this.setPreviousError(error);

            return output;
        }

        /**
         * Resets the current PID by setting the integral part to zero
         * so the PID can be reused after some time of de-activation
         */
        public void reset(){
            this.integral = 0;
        }

        /*
        Getters and setters
         */

        /**
         * get the integral part (saved over the course of the algorithm)
         * @return the integral part of the PID
         */
        private float getIntegral() {
            return integral;
        }

        /**
         * set the integral part of the PID (saved over the course of the algorithm)
         */
        private void setIntegral(float integral) {
            this.integral = integral;
        }

        /**
         * get the error of the previous iteration
         */
        private float getPreviousError() {
            return previousError;
        }

        /**
         * Set the previous error (used when the new values for the error are loaded)
         */
        private void setPreviousError(float previousError) {
            this.previousError = previousError;
        }

        /**
         * The set point is the desired value used for reference, in our case it is 0.0
         */
        public float getSetPoint() {
            return setPoint;
        }

        /**
         * Set the set point of the PID
         */
        public void setSetPoint(float setPoint) {
            this.setPoint = setPoint;
        }

        /**
         * Constant used for the gain (proportional) part of the PID
         */
        private float getGainConstant() {
            return gainConstant;
        }

        /**
         * Constant used for the integral part of the PID
         */
        private float getIntegralConstant() {
            return integralConstant;
        }

        /**
         * Constant used for the derivative part of the PID
         */
        private float getDerivativeConstant() {
            return derivativeConstant;
        }

        public void setGainConstant(float gainConstant) {
            this.gainConstant = gainConstant;
        }

        public void setIntegralConstant(float integralConstant) {
            this.integralConstant = integralConstant;
        }

        public void setDerivativeConstant(float derivativeConstant) {
            this.derivativeConstant = derivativeConstant;
        }

        private float integral = 0.0f;
        private float previousError = 0.0f;
        private float setPoint = 0.0f;
        private float gainConstant;
        private float integralConstant;
        private float derivativeConstant;
        private float prevCalcOutput;
    }

    /**
     * Wrapper the the creation of an anonymous class for the interface AutopilotTurn
     * the semantics of the parameters are exactly the same as specified in the interface
     * @param center the center of the turn
     * @param entry the entry point of the turn relative to the center
     * @param exit the exit point of the turn relative to the center
     * @param angle the angle to rotate before exiting the turn, >=0 counterclockwise turn, < 0 clockwise
     * @param radius the radius of the turn
     * @return a AutopilotTurn object with the specified parameters
     */
    protected static AutopilotTurn createTurn(Vector center, Vector entry, Vector exit, float angle, float radius){
        return new AutopilotTurn() {
            @Override
            public Vector getTurnCenter() {
                return center;
            }

            @Override
            public Vector getEntryPoint() {
                return entry;
            }

            @Override
            public float getTurnRadius() {
                return radius;
            }

            @Override
            public float getTurnAngle() {
                return angle;
            }

            @Override
            public Vector getExitPoint() {
                return exit;
            }
        };
    }

    /**
     * A class for configuring the controller for a turn and generating the control actions needed
     * to make the specified turn given the current and previous inputs of the autopilot
     * note: on every new turn a new turn controller has to be initialized
     */
    protected class TurnControlBeta {

        public TurnControlBeta(AutopilotTurn turn, PhysXEngine.TurnPhysX turnPhysX, StandardOutputs standardOutputs, float cruisingAltitude) {
            this.turn = turn;
            this.turnPhysX = turnPhysX;
            this.angleToGo = turn.getTurnAngle();
            this.cruisingAltitude = cruisingAltitude;
            this.standardOutputs = standardOutputs;
            configureTurn(turn);
        }

        /**
         * Configures the controller for making the current turn
         * --> sets the roll needed to make the specified turn
         * --> sets the velocity needed to make the specified turn
         * @param turn the turn to configure the controller for
         */
        private void configureTurn(AutopilotTurn turn){
            //calculate the reference roll and velocity for making the turn
            float roll = calculateBankingRoll(turn);
            float velocity = calculateTurnVelocity(roll);

            //save the results
            this.setBankingTurnRoll(roll);
            this.setTurnVelocity(velocity);
        }

        /**
         * Getter for the control actions for the turn controller
         * the control outputs contain the commands for the drone to make the specified turn
         * @param currentInputs the inputs most recently received from the testbed
         * @param previousInputs the inputs previously received from the testbed
         * @return a control outputs object containing the outputs for the drone to make the turn
         */
        protected AutopilotOutputs getControlActions(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
            //create the control outputs object to store the control actions for the drone
            ControlOutputs outputs = new ControlOutputs(this.getStandardOutputs());

            //get all the control actions needed to make the turn
            rollControl(outputs, currentInputs, previousInputs);
            pitchControl(outputs, currentInputs, previousInputs);
            angleOfAttackControl(getAoaErrorMargin(), outputs, currentInputs, previousInputs);
            thrustControl(outputs, currentInputs, previousInputs);

            //update the angle to go every time the turn control is invoked:
            AutopilotTurn currentTurn = this.getTurn();
            float deltaAngle = this.calcDeltaAngle(currentInputs, previousInputs, currentTurn);
            reduceAngleToGo(deltaAngle);

            outputs.capInclinations(getMainDeltaIncl(), getMainDeltaIncl(), getHorizontalDeltaIncl(), 0);
            return outputs;
        }


        /**
         * Calculates the thrust outputs for maintaining the reference velocity
         * needs to be called after the inclinations are known
         * @param outputs the outputs to write the control actions to and to read the wing inclinations from to determine
         *                the thrust needed to maintain the reference velocity
         * @param currentInputs the latest inputs from the testbed
         * @param previousInputs the previous inputs from the testbed
         */
        private void thrustControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
            //get the parameters needed to call the cruise control
            float referenceVelocity = this.getTurnVelocity();
            PIDController thrustPID = this.getThrustController();
            Controller.this.flightCruiseControl(outputs, currentInputs, previousInputs, thrustPID, referenceVelocity);
        }

        /**
         * Generates the control actions to keep the roll in check during a banking turn with turning radius
         * ||dronePos - turnCenter|| and with center turnCenter
         * @param outputs the outputs to write the calculated results to
         * @param currentInputs the latest inputs received by the autopilot from the testbed
         * @param previousInputs the inputs previously received from the testbed
         */
        private void rollControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs) {
            //calculate the angle needed to make the turn (may be done only once in the future)
            //get the parameters first:

            //calculate the roll needed to make the turn
            float bankingRoll = this.getBankingTurnRoll();
            //correct the banking roll for the error on the turn radius
            float correctedBanking = correctReferenceRoll(bankingRoll, currentInputs, previousInputs);
            //get the PID and the parameters needed to get the errorOutput
            float roll = extractRoll(currentInputs);
            float rollError = correctedBanking - roll; // the error on the roll of the drone
            float deltaTime = getDeltaTime(currentInputs, previousInputs);

//            System.out.println("banking roll needed: " + bankingRoll + ", actual roll: " + roll + ", error: " + rollError);

            PIDController rollController = this.getRollController();
            float pidRollError = rollController.getPIDOutput(rollError, deltaTime);

            //adjust the wings accordingly
            //if the roll error was negative we need to steer to the right, if the roll error was positive
            //we need to steer to the left (draw it yourself if you don't believe me) because the PID inverts
            //the error value we need to steer to the right if we have a positive pidRollError and to the left
            //if we have a positive pidRollError
            float mainStableInclination = getMainStable();
            float mainDeltaIncl = getMainDeltaIncl();
            float requiredRightMain = mainStableInclination - pidRollError;
            float requiredLeftMain = mainStableInclination + pidRollError;

            float cappedRightMain = capInclination(requiredRightMain, mainStableInclination, mainDeltaIncl);
            float cappedLeftMain = capInclination(requiredLeftMain, mainStableInclination, mainDeltaIncl);

            outputs.setRightWingInclination(cappedRightMain);
            outputs.setLeftWingInclination(cappedLeftMain);
        }

        /**
         * Method to correct the reference roll of the drone to account for deviation in the current radius of
         * the circle the drone is flying in and the desired radius
         * @param referenceRoll the reference roll to correct, this is the roll that is used as a reference for the
         *                      roll controller
         * @param currentInputs the inputs most recently received from the testbed
         * @param previousInputs  the inputs previously received from the testbed
         * @return the corrected roll
         */
        private float correctReferenceRoll(float referenceRoll, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
            //get the current turn
            AutopilotTurn currentTurn = this.getTurn();
            float turnRadius = currentTurn.getTurnRadius();

            //get the current distance from the center (measured in ground coordinates)
            Vector droneGroundPos = extractGroundPosition(currentInputs);
            Vector turnCenter = currentTurn.getTurnCenter();
            Vector radiusVector = droneGroundPos.vectorDifference(turnCenter);
            float actualRadius =  radiusVector.getSize();
            float errorInput = actualRadius-turnRadius;
            float deltaTime = getDeltaTime(currentInputs, previousInputs);
            PIDController rollCorrectionPID = this.getRollCorrectController();


            float errorOutput = rollCorrectionPID.getPIDOutput(errorInput, deltaTime);
            //if we're making the turn too sharp the error input will be negative (the output positive)
            //if the turn is too shallow we the error input will be positive (the output negative)
            //thus if the output is positive the reference roll must become smaller (we're steering to sharp)
            //and if the output is negative the roll must become sharper
            float scalingFactor = this.getCorrectRollFactor();
            //get the correction based on the error and a scaling factor
            float correctedReference = (referenceRoll  -  errorOutput*scalingFactor);
            //log the error TODO remove after debugging
            float percentageCap = this.getRollReferenceCorrectCapPercentage();
            correctedReference = percentageCap(correctedReference, referenceRoll, percentageCap);
            //errorLog(correctedReference);
//            errorLog(errorInput);
            //get the error ratio, if the the drone is currently to far from the center we have to roll harder
            //if we're to close we may loosen the roll a bit
            return correctedReference;
        }

        /**
         * Caps the input within an percentage error of the reference
         * the acceptable range is defined as (reference*(1-maxErrorPercent), (reference*(1+maxErrorPercent))
         * @param input the inputs to cap
         * @param reference the reference point, this is the point where the borders are calculated from
         * @param maxErrorPercentage the error percentage
         * @return if the input is within range (reference*(1-maxErrorPercent), (reference*(1+maxErrorPercent)) it is
         *         returned unchanged, if it lies outside of the range, returns the closest border point of the range
         */
        private float percentageCap(float input, float reference, float maxErrorPercentage){
            //establish borders
            float lower = reference*(1-maxErrorPercentage);
            float upper = reference*(1+maxErrorPercentage);

            //cap the actual input, if it lies outside of the range, bring it to the closest border
            if(input > upper){
                return upper;
            }
            if(input < lower){
                return lower;
            }

            return input;
        }

        /**
         * Getter for the control actions needed to keep the drone at the cruising altitude during the turn
         * @param outputs the outputs of the drone to write the result to
         * @param currentInputs the inputs most recently received from the testbed
         * @param previousInputs the inputs previously received from the testbed
         */
        private void pitchControl(ControlOutputs outputs, AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs){
            //get the reference value
            Vector pitchReferencePoint = this.getPitchReferencePoint(currentInputs);
            float pitchError = this.getPitchError(currentInputs, pitchReferencePoint);
            float deltaTime = getDeltaTime(currentInputs, previousInputs);
            //feed the results into the pid controller
            PIDController pitchPid = this.getPitchController();
            float pidResult = pitchPid.getPIDOutput(pitchError, deltaTime);
            //if the pid result is positive: the set point is larger than the input -> lower the pitch (pos inclination)
            //if the pid result is negative: the set point is smaller than the input -> increase the pitch (neg inclination)
            float horizontalInclination = getHorizontalStable() + pidResult;
            horizontalInclination = capInclination(horizontalInclination, getHorizontalStable(), getHorizontalDeltaIncl());
            outputs.setHorStabInclination(horizontalInclination);
        }

        /**
         * Calculates the reference point used for the pitch controller, this controller is used to maintain the cruising altitude
         * the reference point is generated in front of the drone with coordinates (0, cruisingAltitude, - lookaheadDistance)
         * (coordinates are specified in the heading axis system, the axis system where roll and pitch are zero)
         * @param currentInputs the latest inputs received by the autopilot from the testbed
         * @return the reference point for the pitch in the world axis system
         * note: this method must be called every time the pitch controls are calculated because the reference point
         *       changes on every iteration
         */
        private Vector getPitchReferencePoint(AutopilotInputs_v2 currentInputs){
            //grab the parameters needed to calculate the reference point
            Vector dronePositionGround = extractGroundPosition(currentInputs);
            Vector droneOrientation = extractOrientation(currentInputs);
            Vector headingDroneHa = new Vector(0,0,-1); // the heading vector of the drone is heading axis
            float cruisingAltitude = this.getCruisingAltitude();
            Vector altitudeVector = new Vector(0,cruisingAltitude, 0);
            float lookaheadDistance = this.getLookaheadDistance();

            //first calculate the position of the reference point in the heading axis system
            Vector referencePitchGroundHa = headingDroneHa.scalarMult(lookaheadDistance); //reference in heading axis at ground level
            //also add the cruising altitude so that we factor the reference altitude in
            Vector referencePitchHa = referencePitchGroundHa.vectorSum(altitudeVector);
            //transform the reference point to the world axis system, this vector is now relative to the position
            //of the drone in the world, so we have to add the ground coordinates (since the altitude is our target)
            Vector referenceWorldRel = PhysXEngine.headingOnWorld(referencePitchHa, droneOrientation);

            //sum the ground coordinates to make the reference point absolute
            return dronePositionGround.vectorSum(referenceWorldRel);

        }

        /**
         * Calculates the error on the pitch of the drone against the reference point of the flight
         * the pitch error is the angle between the heading vector (zero roll) in the pitch axis system
         * and the vector pointing from the drone to the reference point ( =difference vector) projected onto
         * the yz-plane of the pitch axis system
         * @param currentInputs the inputs most recently received from the testbed
         * @param referencePoint the reference point to calculate the pitch error for
         * @return the angle as described above with the sign indicating the direction of the error
         *         if the pitch error is positive, extra pitch is required (steering upwards)
         *         if the pitch error is negative, lesser pitch is required (steering downwards)
         */
        private float getPitchError(AutopilotInputs_v2 currentInputs, Vector referencePoint){
            //grab the parameters needed fo the calculation
            Vector droneHeadingPa = new Vector(0,0,-1); //the heading vector of the drone in pitch axis
            Vector yzNormalPa = new Vector(1,0,0); // normal of the yz-plane in pitch axis
            Vector dronePosition = extractPosition(currentInputs);
            Vector droneOrientation = extractOrientation(currentInputs);

            //calculate the difference vector and transform it to the pitch axis system
            //difference vector points from the drone position to the reference point
            Vector diffVector =  referencePoint.vectorDifference(dronePosition);
            Vector diffPa = PhysXEngine.worldOnPitch(diffVector, droneOrientation);

            //project the diff vector in pitch axis system onto the yz plane of the pitch axis
            Vector projDiffPa = diffPa.orthogonalProjection(yzNormalPa);

            //calculate the angle between the heading vector and the projected diff vector
            float pitchErrorAngle = projDiffPa.getAngleBetween(droneHeadingPa);

            //also calculate the direction of the error, take the vector product of the heading and the diff vector
            //if the x-component is positive the drone has to pitch upwards, if it is negative the drone has
            //to pitch downwards to reach the desired altitude/pitch
            float direction = signum(droneHeadingPa.crossProduct(projDiffPa).getxValue());

            //multiply to get the error
            float pitchError = direction*abs(pitchErrorAngle);

            //return the result while checking for NaN, if so return harmless (?) value
            return Float.isNaN(pitchError) ? 0 : pitchError;
        }

        /**
         * Checks if the controller has already started the turn
         * @return true if and only if !floatEquals(turnAngle, angleToGo)
         */
        protected boolean hasStartedTurn(){
            AutopilotTurn turn = this.getTurn();
            float turnAngle = turn.getTurnAngle();
            float angleToGo = this.getAngleToGo();

            return !floatEquals(turnAngle, angleToGo);
        }
        /**
         * Checks if the drone has finished making the current specified turn
         * @return true if and only if the signs of getAngleToGo() and turn.getTurnAngle() differ
         * note: the working is based on the rotation that the drone covers during one iteration by subtracting
         * the delta angle from the angle that the drone still has to do. For counterclockwise rotation both
         * angle to go and the delta angle are positive such that the angle to go will slowly decrease to zero
         * and will finally pass it, causing a negative angle to go and a positive turn angle (because counterclockwise)
         *
         * for a clockwise rotation both the turn angle and the delta angle are negative such that the angle to
         * go will increase to zero and ultimately pass it, causing (again) a difference in sign of the angles
         *
         * extra: the sign of the delta angle is determined by the vector product
         * of the vector pointing from the center to the previous position and the vector pointing from the center
         * to the current position (all coordinates in the xz plane)
         *
         * for more info see the notes --> contact Martijn
         */
        protected boolean hasFinishedTurn(){

            //get the specifications for the turn we're currently making
            AutopilotTurn turn = this.getTurn();
            float turnAngle = turn.getTurnAngle();

            //check if we've made the whole turn this can be checked easily by comparing the signs of the
            //angle to go and the turn angle, if they differ the angle is finished
            float angleToGo = this.getAngleToGo();
            return signum(angleToGo) != signum(turnAngle);
        }

        /**
         * Calculates the difference in the angle to go based on the previous and current inputs
         * the angle to go decreases to zero if the turn is counterclockwise
         * and increases to zero if the turn is clockwise
         * --> this method is used as a prelude to the increment angle to go and also for the final turn
         * @param currentInputs the inputs most recently received from the testbed
         * @param previousInputs the inputs previously received from the testbed
         * @param turn the turn to make
         */
        protected float calcDeltaAngle(AutopilotInputs_v2 currentInputs, AutopilotInputs_v2 previousInputs, AutopilotTurn turn) {
            //get the current and previous location of the drone in the xz-plane
            Vector currentPos = extractGroundPosition(currentInputs);
            Vector previousPos = extractGroundPosition(previousInputs);

            //get the location of the center of the current turn
            Vector turnCenter = turn.getTurnCenter();

            //calculate the (unit) difference vectors between the inputs and the turn center
            Vector previousTurnVector = previousPos.vectorDifference(turnCenter).normalizeVector();
            Vector currentTurnVector = currentPos.vectorDifference(turnCenter).normalizeVector();

            //get the angle difference between them both (this is the part of the turn that we've made
            //during the last iteration (we still have to determine the sign)
            float turnDiffAngle = abs(previousTurnVector.getAngleBetween(currentTurnVector));

            //determine the sign, take the vector product of the previous and the current turn vector
            //take the y-component of the product and take the sign
            float sign = signum(previousTurnVector.crossProduct(currentTurnVector).getyValue());

            //calculate and return the delta angle
            float deltaAngle = sign*turnDiffAngle;
            return deltaAngle;
        }

        /**
         * Calculates the roll needed to make the given turn
         * @param currentTurn the turn to calculate the banking roll for
         * @return the roll needed to make the banking turn as specified above
         * note: negative roll means turn to right and positive roll means turn to left
         */
        private float calculateBankingRoll(AutopilotTurn currentTurn){
            //first calculate the turning radius & calculate the angle needed to bank
            float bankingAngle = calculateBankingAngle(currentTurn);

            //the banking angle will always be positive so we also need to get the direction needed
            // if the turn is counterclockwise (positive turn angle) we need to turn to the left --> pos roll
            // if the turn is clockwise (negative turn angle) we need to turn to the right --> neg roll
            // it is nice to know that the counter clockwise rotation is a positive angle and the clockwise rotation
            // is a negative angle

            //so if clockwise rotation --> negative angle and negative roll
            //and for counter clockwise rotation --> positive angle and positive roll
            return signum(currentTurn.getTurnAngle()) * abs(bankingAngle);
        }

        /**
         * Calculates the banking angle to make the given turn
         * @param currentTurn  the turn to calculate the banking angle for
         * @return the banking angle the drone needs to maintain for turning with the given radius (in radians)
         */
        private float calculateBankingAngle(AutopilotTurn currentTurn){
            //get the turn physics responsible
            PhysXEngine.TurnPhysX turnPhysX = this.getTurnPhysX();

            return turnPhysX.getBankingAngle(currentTurn, getMainStable());
            //return the roll
        }

        /**
         * Calculates the reference velocity needed to keep the drone at the same altitude during the turn
         * this is the reference velocity passed to the thrust controller
         * @param roll the roll wherefore the altitude must remain the same
         * @return the velocity needed to fly level in m/s
         */
        private float calculateTurnVelocity(float roll){
            //get the turn physics
            PhysXEngine.TurnPhysX turnPhysX = this.getTurnPhysX();
            //get the other parameters needed
            float mainStable = getMainStable();
            //calculate
            return turnPhysX.calcTurnVelocity(roll, mainStable);

        }

        /**
         * Getter for the turn wherefore this instance was configured
         * @return the autopilot turn object wherefore this instance was configured
         */
        private AutopilotTurn getTurn() {
            return turn;
        }

        /**
         * Getter for the turn physics engine used to calculate the physics related stuff for making the turn
         * @return the turn physics engine
         */
        private PhysXEngine.TurnPhysX getTurnPhysX() {
            return turnPhysX;
        }

        /**
         * Getter for the rotation around the center point of the turn that the drone has yet to do
         * before it has finished the turn
         * @return the rotation that the drone has to do before it has finished the turn in radians
         *         note: angleToGo is negative for clockwise rotations and positive for counter clockwise rotations
         */
        private float getAngleToGo() {
            return angleToGo;
        }

        /**
         * Decrements the angle to go with the given delta angle
         * @param deltaAngle the rotation around the center that was achieved during the last iteration
         *                   in radians
         *                   note: may me negative in the case that we need to do a clockwise turn, needs to be
         *                   positive if we're doing a counter clockwise turn
         */
        private void reduceAngleToGo(float deltaAngle) {
            this.angleToGo -= deltaAngle;
        }

        /**
         * Resets the state of the angle to go variable
         * after the call the angle to go is yet again equal to the angle needed to make the whole turn
         * --> must be called if the controller is to be re-used for a new turn
         */
        protected void resetAngleToGo(){
            AutopilotTurn turn = this.getTurn();
            float turnAngle = turn.getTurnAngle();
            //hard-reset the angle to go (not normal flow)
            this.angleToGo = turnAngle;
        }


        /**
         * Getter for te roll that the drone needs to have to make the current turn
         * @return the reference roll for the drone to make the turn in radians.
         */
        private float getBankingTurnRoll() {
            return bankingTurnRoll;
        }

        /**
         * Setter for the roll required to make the specified turn
         * @param bankingTurnRoll the reference roll in radians
         */
        private void setBankingTurnRoll(float bankingTurnRoll) {
            this.bankingTurnRoll = bankingTurnRoll;
        }

        /**
         * Getter for the velocity needed for the drone to maintain a stable altitude during the turn
         * this is the reference velocity to be fed into the thrust controller
         * @return the reference velocity needed to be maintained during the turn in meters
         */
        private float getTurnVelocity() {
            return turnVelocity;
        }

        /**
         * Setter for the reference velocity needed to make the turn with a stable altitude
         * @param turnVelocity the reference velocity for the thrust controller in m/s
         */
        private void setTurnVelocity(float turnVelocity) {
            this.turnVelocity = turnVelocity;
        }

        /**
         * Getter for the lookahead distance, the distance between the drone and the pitch reference point
         * expressed in ground coordinates (the distance in the xz-plane)
         * @return the lookahead distance used to generate the pitch reference point in meters
         */
        private float getLookaheadDistance() {
            return lookaheadDistance;
        }

        /**
         * Setter for the lookahead distance of the drone (see getter for more info)
         * @param lookaheadDistance the distance used to generate the reference point in meters
         */
        private void setLookaheadDistance(float lookaheadDistance) {
            this.lookaheadDistance = lookaheadDistance;
        }

        /**
         * Getter for the cruising altitude of the drone, this is the altitude the drone has to maintain during a turn
         * @return the cruising altitude in meters
         */
        private float getCruisingAltitude() {
            return cruisingAltitude;
        }

        /**
         * Getter for the percentage cap on the reference roll
         * the correction is used to counter an error in radius of the turn that the drone is currently making
         * in respect to the current turn
         * @return the reference correction correction cap range (0,1)
         */
        private float getRollReferenceCorrectCapPercentage() {
            return rollReferenceCorrectCapPercentage;
        }

        /**
         * Getter for the correction factor on the roll, used to scale the error on the roll
         * @return the scale factor for correcting the roll
         */
        private float getCorrectRollFactor() {
            return correctRollFactor;
        }

        /**
         * Getter for the standard output for the drone
         * @return the standard outputs
         */
        private StandardOutputs getStandardOutputs() {
            return standardOutputs;
        }

        /**
         * The turn that the turn state is specifying
         */
        private final AutopilotTurn turn;

        /**
         * The rotation angle that the drone has still to make before the turn is finished
         */
        private float angleToGo;

        /**
         * The roll needed to make the turn in the specified radius
         */
        private float bankingTurnRoll;

        /**
         * The velocity needed to fly in the same xz-plane during the turn (maintain a stable y-coordinate)
         */
        private float turnVelocity;

        /**
         * The distance between the drone and the pitch reference point measured in ground coordinates
         * this distance is used to generate the pitch reference point for the drone
         */
        private float lookaheadDistance = 100f;

        /**
         * The cruising altitude that the controller has to maintain during the flight
         */
        private final float cruisingAltitude;

        /**
         * The turn PhysX object used by the autopilot to make turns
         * --> calculates banking angles and such
         */
        private final PhysXEngine.TurnPhysX turnPhysX;

        /**
         * The variable that indicates a percentage cap on the correction that is made on the roll reference
         * of the drone
         */
        private final float rollReferenceCorrectCapPercentage = 0.10f;


        /**
         * The factor used to scale the roll factor correction
         * 100 in denominator = error distance in meters
         * 100 in numerator = for converting the error against the error distance to percent
         * PI/180 = to convert an angle from degree to radians
         */
        private final float correctRollFactor = (float) ((100*PI)/(100*180));

        /**
         * The standard outputs of the drone, these are used to create a new ControlOutputs object
         */
        private final StandardOutputs standardOutputs;

        /*
        Methods belonging to the standard outputs
         */

        private float getMainStable(){
            return standardOutputs.getStandardLeftMainInclination();
        }

        private float getHorizontalStable(){
            return standardOutputs.getStandardHorizontalStabilizerInclination();
        }


        /*
        Controllers for the flight
         */

        /**
         * Controllers needed for banking the drone for a given radius
         * --> thrust controller: needed for the cruise control maintaining the velocity
         * --> roll controller: needed to keep the roll stable to maintain a good bank
         * --> altitude controller: needed to keep the drone at the same level (constant height)
         * note: the roll and the altitude controllers need to react slowly to changes (so the control actions
         * do not go in overdrive, maybe use low pass filter?)
         */

        /**
         * Getter for the banking thrust PID controller, this PID controller needs to be passed
         * to the cruise control method implemented in the main controller class
         * @return a pid controller tuned to maintain the reference velocity of the autopilot
         */
        private PIDController getThrustController() {
            return thrustController;
        }

        /**
         * Getter for the roll controller, this controller is responsible for keeping the right rolling angle for
         * the drone to make a banking turn in the provided airspace
         * @return the PID controller tuned for reaching and maintaining the roll needed for banked turn
         */
        private PIDController getRollController() {
            return bankingRollController;
        }


        /**
         * Getter for the pitch controller of the turning controller, this is the controller for maintaining
         * the reference altitude during the turn (the reference altitude is defined as the cruising altitude, assigned
         * by the autopilot overseer)
         * @return the PID controller tuned for controlling the pitch
         */
        private PIDController getPitchController() {
            return pitchController;
        }

        /**
         * Controller for altering the reference roll such that the drone keeps a distance equal to the radius
         * of the turn from the center
         * @return the controller tuned for correcting the reference roll
         */
        private PIDController getRollCorrectController(){
            return rollCorrectController;
        }

        private final static float THRUST_GAIN = 1.0f;
        private final static float THRUST_INTEGRAL = 0.2f ;
        private final static float THRUST_DERIVATIVE = 0.1f;
        private final PIDController thrustController = new PIDController(THRUST_GAIN, THRUST_INTEGRAL, THRUST_DERIVATIVE);

        private final static float ROLL_GAIN = 1.0f;
        private final static float ROLL_INTEGRAL = 0.0f;
        private final static float ROLL_DERIVATIVE = 0.5f;
        private final PIDController bankingRollController = new PIDController(ROLL_GAIN, ROLL_INTEGRAL, ROLL_DERIVATIVE);

        private final static float PITCH_GAIN = 1.0f;
        private final static float PITCH_INTEGRAL = 0.6f;
        private final static float PITCH_DERIVATIVE = 0.7f;
        private final PIDController pitchController = new PIDController(PITCH_GAIN, PITCH_INTEGRAL, PITCH_DERIVATIVE);


        //TODO try other approach to correct for the roll
        private final static float ROLL_CORRECT_GAIN = 0.3f;
        private final static float ROLL_CORRECT_INTEGRAL = 0.f;
        private final static float ROLL_CORRECT_DERIVATIVE = 1.0f;
        private final PIDController rollCorrectController = new PIDController(ROLL_CORRECT_GAIN, ROLL_CORRECT_INTEGRAL, ROLL_CORRECT_DERIVATIVE);

        /*
        Some constants needed to steer the drone (and their getters)
         */

        /**
         * Getter for the maximum deviance of the main wing inclination, used to cap the wing inclination of the drone
         * @return the main wing inclination deviation cap in radians
         */
        private float getMainDeltaIncl(){
            return MAIN_DELTA_INCL;
        }

        /**
         * Getter for the maximum deviance of the horizontal stabilizer inclination, used to cap the wing inclination of the drone
         * @return the horizontal stabilizer inclination cap in radians
         */
        private float getHorizontalDeltaIncl(){
            return HORIZONTAL_DELTA_INCL;
        }

        /**
         * Getter for the safety margin to be used when adjusting the wing inclinations such that
         * the inclination wont exceed the AOA
         * @return the safety margin in radians
         */
        private float getAoaErrorMargin(){
            return AOA_ERROR_MARGIN;
        }

        private final static float MAIN_DELTA_INCL = (float) (2*PI/180);
        private final static float HORIZONTAL_DELTA_INCL= (float) (8*PI/180);
        private final static float AOA_ERROR_MARGIN = (float) (2*PI/180);
    }

}
